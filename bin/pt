#!/usr/bin/env perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Date/Format.pm"} = <<'DATE_FORMAT';
  # Copyright (c) 1995-2009 Graham Barr. This program is free
  # software; you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  
  package Date::Format;
  
  use     strict;
  use     vars qw(@EXPORT @ISA $VERSION);
  require Exporter;
  
  $VERSION = "2.24";
  @ISA     = qw(Exporter);
  @EXPORT  = qw(time2str strftime ctime asctime);
  
  sub time2str ($;$$)
  {
   Date::Format::Generic->time2str(@_);
  }
  
  sub strftime ($\@;$)
  {
   Date::Format::Generic->strftime(@_);
  }
  
  sub ctime ($;$)
  {
   my($t,$tz) = @_;
   Date::Format::Generic->time2str("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  sub asctime (\@;$)
  {
   my($t,$tz) = @_;
   Date::Format::Generic->strftime("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  ##
  ##
  ##
  
  package Date::Format::Generic;
  
  use vars qw($epoch $tzname);
  use Time::Zone;
  use Time::Local;
  
  sub ctime
  {
   my($me,$t,$tz) = @_;
   $me->time2str("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  sub asctime
  {
   my($me,$t,$tz) = @_;
   $me->strftime("%a %b %e %T %Y\n", $t, $tz); 
  }
  
  sub _subs
  {
   my $fn;
   $_[1] =~ s/
  		%(O?[%a-zA-Z])
  	   /
                  ($_[0]->can("format_$1") || sub { $1 })->($_[0]);
  	   /sgeox;
  
   $_[1];
  }
  
  sub strftime 
  {
   my($pkg,$fmt,$time);
  
   ($pkg,$fmt,$time,$tzname) = @_;
  
   my $me = ref($pkg) ? $pkg : bless [];
  
   if(defined $tzname)
    {
     $tzname = uc $tzname;
  
     $tzname = sprintf("%+05d",$tzname)
  	unless($tzname =~ /\D/);
  
     $epoch = timegm(@{$time}[0..5]);
  
     @$me = gmtime($epoch + tz_offset($tzname) - tz_offset());
    }
   else
    {
     @$me = @$time;
     undef $epoch;
    }
  
   _subs($me,$fmt);
  }
  
  sub time2str
  {
   my($pkg,$fmt,$time);
  
   ($pkg,$fmt,$time,$tzname) = @_;
  
   my $me = ref($pkg) ? $pkg : bless [], $pkg;
  
   $epoch = $time;
  
   if(defined $tzname)
    {
     $tzname = uc $tzname;
  
     $tzname = sprintf("%+05d",$tzname)
  	unless($tzname =~ /\D/);
  
     $time += tz_offset($tzname);
     @$me = gmtime($time);
    }
   else
    {
     @$me = localtime($time);
    }
   $me->[9] = $time;
   _subs($me,$fmt);
  }
  
  my(@DoW,@MoY,@DoWs,@MoYs,@AMPM,%format,@Dsuf);
  
  @DoW = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  
  @MoY = qw(January February March April May June
            July August September October November December);
  
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  
  @AMPM = qw(AM PM);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  %format = ('x' => "%m/%d/%y",
             'C' => "%a %b %e %T %Z %Y",
             'X' => "%H:%M:%S",
            );
  
  my @locale;
  my $locale = "/usr/share/lib/locale/LC_TIME/default";
  local *LOCALE;
  
  if(open(LOCALE,"$locale"))
   {
    chop(@locale = <LOCALE>);
    close(LOCALE);
  
    @MoYs = @locale[0 .. 11];
    @MoY  = @locale[12 .. 23];
    @DoWs = @locale[24 .. 30];
    @DoW  = @locale[31 .. 37];
    @format{"X","x","C"} =  @locale[38 .. 40];
    @AMPM = @locale[41 .. 42];
   }
  
  sub wkyr {
      my($wstart, $wday, $yday) = @_;
      $wday = ($wday + 7 - $wstart) % 7;
      return int(($yday - $wday + 13) / 7 - 1);
  }
  
  ##
  ## these 6 formatting routins need to be *copied* into the language
  ## specific packages
  ##
  
  my @roman = ('',qw(I II III IV V VI VII VIII IX));
  sub roman {
    my $n = shift;
  
    $n =~ s/(\d)$//;
    my $r = $roman[ $1 ];
  
    if($n =~ s/(\d)$//) {
      (my $t = $roman[$1]) =~ tr/IVX/XLC/;
      $r = $t . $r;
    }
    if($n =~ s/(\d)$//) {
      (my $t = $roman[$1]) =~ tr/IVX/CDM/;
      $r = $t . $r;
    }
    if($n =~ s/(\d)$//) {
      (my $t = $roman[$1]) =~ tr/IVX/M../;
      $r = $t . $r;
    }
    $r;
  }
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_P { lc($_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0]) }
  
  sub format_d { sprintf("%02d",$_[0]->[3]) }
  sub format_e { sprintf("%2d",$_[0]->[3]) }
  sub format_H { sprintf("%02d",$_[0]->[2]) }
  sub format_I { sprintf("%02d",$_[0]->[2] % 12 || 12)}
  sub format_j { sprintf("%03d",$_[0]->[7] + 1) }
  sub format_k { sprintf("%2d",$_[0]->[2]) }
  sub format_l { sprintf("%2d",$_[0]->[2] % 12 || 12)}
  sub format_L { $_[0]->[4] + 1 }
  sub format_m { sprintf("%02d",$_[0]->[4] + 1) }
  sub format_M { sprintf("%02d",$_[0]->[1]) }
  sub format_q { sprintf("%01d",int($_[0]->[4] / 3) + 1) }
  sub format_s { 
     $epoch = timelocal(@{$_[0]}[0..5])
  	unless defined $epoch;
     sprintf("%d",$epoch) 
  }
  sub format_S { sprintf("%02d",$_[0]->[0]) }
  sub format_U { wkyr(0, $_[0]->[6], $_[0]->[7]) }
  sub format_w { $_[0]->[6] }
  sub format_W { wkyr(1, $_[0]->[6], $_[0]->[7]) }
  sub format_y { sprintf("%02d",$_[0]->[5] % 100) }
  sub format_Y { sprintf("%04d",$_[0]->[5] + 1900) }
  
  sub format_Z {
   my $o = tz_local_offset(timelocal(@{$_[0]}[0..5]));
   defined $tzname ? $tzname : uc tz_name($o, $_[0]->[8]);
  }
  
  sub format_z {
   my $t = timelocal(@{$_[0]}[0..5]);
   my $o = defined $tzname ? tz_offset($tzname, $t) : tz_offset(undef,$t);
   sprintf("%+03d%02d", int($o / 3600), int(abs($o) % 3600) / 60);
  }
  
  sub format_c { &format_x . " " . &format_X }
  sub format_D { &format_m . "/" . &format_d . "/" . &format_y  }      
  sub format_r { &format_I . ":" . &format_M . ":" . &format_S . " " . &format_p  }   
  sub format_R { &format_H . ":" . &format_M }
  sub format_T { &format_H . ":" . &format_M . ":" . &format_S }
  sub format_t { "\t" }
  sub format_n { "\n" }
  sub format_o { sprintf("%2d%s",$_[0]->[3],$Dsuf[$_[0]->[3]]) }
  sub format_x { my $f = $format{'x'}; _subs($_[0],$f); }
  sub format_X { my $f = $format{'X'}; _subs($_[0],$f); }
  sub format_C { my $f = $format{'C'}; _subs($_[0],$f); }
  
  sub format_Od { roman(format_d(@_)) }
  sub format_Oe { roman(format_e(@_)) }
  sub format_OH { roman(format_H(@_)) }
  sub format_OI { roman(format_I(@_)) }
  sub format_Oj { roman(format_j(@_)) }
  sub format_Ok { roman(format_k(@_)) }
  sub format_Ol { roman(format_l(@_)) }
  sub format_Om { roman(format_m(@_)) }
  sub format_OM { roman(format_M(@_)) }
  sub format_Oq { roman(format_q(@_)) }
  sub format_Oy { roman(format_y(@_)) }
  sub format_OY { roman(format_Y(@_)) }
  
  sub format_G { int(($_[0]->[9] - 315993600) / 604800) }
  
  1;
  __END__
  
  =head1 NAME
  
  Date::Format - Date formating subroutines
  
  =head1 SYNOPSIS
  
  	use Date::Format;
  	
  	@lt = localtime(time);
  	
  	print time2str($template, time);
  	print strftime($template, @lt);
  	
  	print time2str($template, time, $zone);
  	print strftime($template, @lt, $zone);
  	
  	print ctime(time);
  	print asctime(@lt);
  	
  	print ctime(time, $zone);
  	print asctime(@lt, $zone);
  
  =head1 DESCRIPTION
  
  This module provides routines to format dates into ASCII strings. They
  correspond to the C library routines C<strftime> and C<ctime>.
  
  =over 4
  
  =item time2str(TEMPLATE, TIME [, ZONE])
  
  C<time2str> converts C<TIME> into an ASCII string using the conversion
  specification given in C<TEMPLATE>. C<ZONE> if given specifies the zone
  which the output is required to be in, C<ZONE> defaults to your current zone.
  
  
  =item strftime(TEMPLATE, TIME [, ZONE])
  
  C<strftime> is similar to C<time2str> with the exception that the time is
  passed as an array, such as the array returned by C<localtime>.
  
  =item ctime(TIME [, ZONE])
  
  C<ctime> calls C<time2str> with the given arguments using the
  conversion specification C<"%a %b %e %T %Y\n">
  
  =item asctime(TIME [, ZONE])
  
  C<asctime> calls C<time2str> with the given arguments using the
  conversion specification C<"%a %b %e %T %Y\n">
  
  =back
  
  =head1 MULTI-LANGUAGE SUPPORT
  
  Date::Format is capable of formating into several languages by creating
  a language specific object and calling methods, see L<Date::Language>
  
  	my $lang = Date::Language->new('German');
  	$lang->time2str("%a %b %e %T %Y\n", time);
  
  I am open to suggestions on this.
  
  =head1 CONVERSION SPECIFICATION
  
  Each conversion specification  is  replaced  by  appropriate
  characters   as   described  in  the  following  list.   The
  appropriate  characters  are  determined  by   the   LC_TIME
  category of the program's locale.
  
  	%%	PERCENT
  	%a	day of the week abbr
  	%A	day of the week
  	%b	month abbr
  	%B 	month
  	%c	MM/DD/YY HH:MM:SS
  	%C 	ctime format: Sat Nov 19 21:05:57 1994
  	%d 	numeric day of the month, with leading zeros (eg 01..31)
  	%e 	like %d, but a leading zero is replaced by a space (eg  1..32)
  	%D 	MM/DD/YY
  	%G	GPS week number (weeks since January 6, 1980)
  	%h 	month abbr
  	%H 	hour, 24 hour clock, leading 0's)
  	%I 	hour, 12 hour clock, leading 0's)
  	%j 	day of the year
  	%k 	hour
  	%l 	hour, 12 hour clock
  	%L 	month number, starting with 1
  	%m 	month number, starting with 01
  	%M 	minute, leading 0's
  	%n 	NEWLINE
  	%o	ornate day of month -- "1st", "2nd", "25th", etc.
  	%p 	AM or PM 
  	%P 	am or pm (Yes %p and %P are backwards :)
  	%q	Quarter number, starting with 1
  	%r 	time format: 09:05:57 PM
  	%R 	time format: 21:05
  	%s	seconds since the Epoch, UCT
  	%S 	seconds, leading 0's
  	%t 	TAB
  	%T 	time format: 21:05:57
  	%U 	week number, Sunday as first day of week
  	%w 	day of the week, numerically, Sunday == 0
  	%W 	week number, Monday as first day of week
  	%x 	date format: 11/19/94
  	%X 	time format: 21:05:57
  	%y	year (2 digits)
  	%Y	year (4 digits)
  	%Z 	timezone in ascii. eg: PST
  	%z	timezone in format -/+0000
  
  C<%d>, C<%e>, C<%H>, C<%I>, C<%j>, C<%k>, C<%l>, C<%m>, C<%M>, C<%q>,
  C<%y> and C<%Y> can be output in Roman numerals by prefixing the letter
  with C<O>, e.g. C<%OY> will output the year as roman numerals.
  
  =head1 LIMITATION
  
  The functions in this module are limited to the time range that can be
  represented by the time_t data type, i.e. 1901-12-13 20:45:53 GMT to
  2038-01-19 03:14:07 GMT.
  
  =head1 AUTHOR
  
  Graham Barr <gbarr@pobox.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1995-2009 Graham Barr. This program is free
  software; you can redistribute it and/or modify it under the same terms
  as Perl itself.
  
  =cut
  
  
DATE_FORMAT

$fatpacked{"Date/Language.pm"} = <<'DATE_LANGUAGE';
  
  package Date::Language;
  
  use     strict;
  use     Time::Local;
  use     Carp;
  use     vars qw($VERSION @ISA);
  require Date::Format;
  
  $VERSION = "1.10";
  @ISA     = qw(Date::Format::Generic);
  
  sub new
  {
   my $self = shift;
   my $type = shift || $self;
  
   $type =~ s/^(\w+)$/Date::Language::$1/;
  
   croak "Bad language"
  	unless $type =~ /^[\w:]+$/;
  
   eval "require $type"
  	or croak $@;
  
   bless [], $type;
  }
  
  # Stop AUTOLOAD being called ;-)
  sub DESTROY {}
  
  sub AUTOLOAD
  {
   use vars qw($AUTOLOAD);
  
   if($AUTOLOAD =~ /::strptime\Z/o)
    {
     my $self = $_[0];
     my $type = ref($self) || $self;
     require Date::Parse;
  
     no strict 'refs';
     *{"${type}::strptime"} = Date::Parse::gen_parser(
  	\%{"${type}::DoW"},
  	\%{"${type}::MoY"},
  	\@{"${type}::Dsuf"},
  	1);
  
     goto &{"${type}::strptime"};
    }
  
   croak "Undefined method &$AUTOLOAD called";
  }
  
  sub str2time
  {
   my $me = shift;
   my @t = $me->strptime(@_);
  
   return undef
  	unless @t;
  
   my($ss,$mm,$hh,$day,$month,$year,$zone) = @t;
   my @lt  = localtime(time);
  
   $hh    ||= 0;
   $mm    ||= 0;
   $ss    ||= 0;
  
   $month = $lt[4]
  	unless(defined $month);
  
   $day  = $lt[3]
  	unless(defined $day);
  
   $year = ($month > $lt[4]) ? ($lt[5] - 1) : $lt[5]
  	unless(defined $year);
  
   return defined $zone ? timegm($ss,$mm,$hh,$day,$month,$year) - $zone
      	    	      : timelocal($ss,$mm,$hh,$day,$month,$year);
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Date::Language - Language specific date formating and parsing
  
  =head1 SYNOPSIS
  
    use Date::Language;
  
    my $lang = Date::Language->new('German');
    $lang->time2str("%a %b %e %T %Y\n", time);
  
  =head1 DESCRIPTION
  
  L<Date::Language> provides objects to parse and format dates for specific languages. Available languages are
  
    Afar                    French                  Russian_cp1251
    Amharic                 Gedeo                   Russian_koi8r
    Austrian                German                  Sidama
    Brazilian               Greek                   Somali
    Chinese                 Hungarian               Spanish
    Chinese_GB              Icelandic               Swedish
    Czech                   Italian                 Tigrinya
    Danish                  Norwegian               TigrinyaEritrean
    Dutch                   Oromo                   TigrinyaEthiopian
    English                 Romanian                Turkish
    Finnish                 Russian
  
  =head1 METHODS
  
  =over
  
  =item time2str
  
  See L<Date::Format/time2str>
  
  =item strftime
  
  See L<Date::Format/strftime>
  
  =item ctime
  
  See L<Date::Format/ctime>
  
  =item asctime
  
  See L<Date::Format/asctime>
  
  =item str2time
  
  See L<Date::Parse/str2time>
  
  =item strptime
  
  See L<Date::Parse/strptime>
  
  =back
  
DATE_LANGUAGE

$fatpacked{"Date/Language/Afar.pm"} = <<'DATE_LANGUAGE_AFAR';
  ##
  ## Afar tables
  ##
  
  package Date::Language::Afar;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Acaada Etleeni Talaata Arbaqa Kamiisi Gumqata Sabti);
  @MoY = (
  "Qunxa Garablu",
  "Kudo",
  "Ciggilta Kudo",
  "Agda Baxis",
  "Caxah Alsa",
  "Qasa Dirri",
  "Qado Dirri",
  "Liiqen",
  "Waysu",
  "Diteli",
  "Ximoli",
  "Kaxxa Garablu"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(saaku carra);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_AFAR

$fatpacked{"Date/Language/Amharic.pm"} = <<'DATE_LANGUAGE_AMHARIC';
  ##
  ## Amharic tables
  ##
  
  package Date::Language::Amharic;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  if ( $] >= 5.006 ) {
  @DoW = (
  "\x{12a5}\x{1211}\x{12f5}",
  "\x{1230}\x{129e}",
  "\x{121b}\x{12ad}\x{1230}\x{129e}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1210}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1265}",
  "\x{1245}\x{12f3}\x{121c}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = ( "\x{1320}\x{12cb}\x{1275}", "\x{12a8}\x{1230}\x{12d3}\x{1275}" );
  
  @Dsuf = ("\x{129b}" x 31);
  }
  else {
  @DoW = (
  "áŠ¥áˆ‘á‹µ",
  "áˆ°áŠž",
  "áˆ›áŠ­áˆ°áŠž",
  "áˆ¨á‰¡á‹•",
  "áˆáˆ™áˆµ",
  "á‹“áˆ­á‰¥",
  "á‰…á‹³áˆœ"
  );
  @MoY = (
  "áŒƒáŠ•á‹©á‹ˆáˆª",
  "áŒá‰¥áˆ©á‹ˆáˆª",
  "áˆ›áˆ­á‰½",
  "áŠ¤á•áˆ¨áˆ",
  "áˆœá‹­",
  "áŒáŠ•",
  "áŒáˆ‹á‹­",
  "áŠ¦áŒˆáˆµá‰µ",
  "áˆ´á•á‰´áˆá‰ áˆ­",
  "áŠ¦áŠ­á‰°á‹á‰ áˆ­",
  "áŠ–á‰¬áˆá‰ áˆ­",
  "á‹²áˆ´áˆá‰ áˆ­"
  );
  @DoWs = map { substr($_,0,9) } @DoW;
  @MoYs = map { substr($_,0,9) } @MoY;
  @AMPM = ( "áŒ á‹‹á‰µ", "áŠ¨áˆ°á‹“á‰µ" );
  
  @Dsuf = ("áŠ›" x 31);
  }
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_AMHARIC

$fatpacked{"Date/Language/Austrian.pm"} = <<'DATE_LANGUAGE_AUSTRIAN';
  ##
  ## Austrian tables
  ##
  
  package Date::Language::Austrian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Jänner Feber März April Mai Juni
  	   Juli August September Oktober November Dezember);
  @MoYs = qw(Jän Feb Mär Apr Mai Jun Jul Aug Sep Oct Nov Dez);
  @DoW  = qw(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag);
  @DoWs = qw(Son Mon Die Mit Don Fre Sam);
  
  use Date::Language::English ();
  @AMPM = @{Date::Language::English::AMPM};
  @Dsuf = @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_AUSTRIAN

$fatpacked{"Date/Language/Brazilian.pm"} = <<'DATE_LANGUAGE_BRAZILIAN';
  ##
  ## Brazilian tables, contributed by Christian Tosta (tosta@cce.ufmg.br)
  ##
  
  package Date::Language::Brazilian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(Domingo Segunda Terça Quarta Quinta Sexta Sábado);
  @MoY = qw(Janeiro Fevereiro Março Abril Maio Junho
  	  Julho Agosto Setembro Outubro Novembro Dezembro);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = (qw(mo ro do ro to to to mo vo no)) x 3;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_BRAZILIAN

$fatpacked{"Date/Language/Chinese.pm"} = <<'DATE_LANGUAGE_CHINESE';
  ##
  ## English tables
  ##
  
  package Date::Language::Chinese;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = qw(æ˜ŸæœŸæ—¥ æ˜ŸæœŸä¸€ æ˜ŸæœŸäºŒ æ˜ŸæœŸä¸‰ æ˜ŸæœŸå›› æ˜ŸæœŸäº” æ˜ŸæœŸå…­);
  @MoY = qw(ä¸€æœˆ äºŒæœˆ ä¸‰æœˆ å››æœˆ äº”æœˆ å…­æœˆ
  	  ä¸ƒæœˆ å…«æœˆ ä¹æœˆ åæœˆ åä¸€æœˆ åäºŒæœˆ);
  @DoWs = map { $_ } @DoW;
  @MoYs = map { $_ } @MoY;
  @AMPM = qw(ä¸Šåˆ ä¸‹åˆ);
  
  @Dsuf = (qw(æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥ æ—¥)) x 3;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_o { sprintf("%2d%s",$_[0]->[3],"æ—¥") }
  1;
DATE_LANGUAGE_CHINESE

$fatpacked{"Date/Language/Chinese_GB.pm"} = <<'DATE_LANGUAGE_CHINESE_GB';
  ##
  ## English tables
  ##
  
  package Date::Language::Chinese_GB;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(ÐÇÆÚÈÕ ÐÇÆÚÒ» ÐÇÆÚ¶þ ÐÇÆÚÈý ÐÇÆÚËÄ ÐÇÆÚÎå ÐÇÆÚÁù);
  @MoY = qw(Ò»ÔÂ ¶þÔÂ ÈýÔÂ ËÄÔÂ ÎåÔÂ ÁùÔÂ
  	  ÆßÔÂ °ËÔÂ ¾ÅÔÂ Ê®ÔÂ Ê®Ò»ÔÂ Ê®¶þÔÂ);
  @DoWs = map { $_ } @DoW;
  @MoYs = map { $_ } @MoY;
  @AMPM = qw(ÉÏÎç ÏÂÎç);
  
  @Dsuf = (qw(ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ ÈÕ)) x 3;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_o { sprintf("%2d%s",$_[0]->[3],"ÈÕ") }
  1;
DATE_LANGUAGE_CHINESE_GB

$fatpacked{"Date/Language/Czech.pm"} = <<'DATE_LANGUAGE_CZECH';
  ##
  ## Czech tables
  ##
  ## Contributed by Honza Pazdziora 
  
  package Date::Language::Czech;
  
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @MoY2 @AMPM %MoY %DoW $VERSION);
  @ISA = qw(Date::Language Date::Format::Generic);
  $VERSION = "1.01";
  
  @MoY = qw(leden únor bøezen duben kvìten èerven èervenec srpen záøí
  	      øíjen listopad prosinec);
  @MoYs = qw(led únor bøe dub kvì èvn èec srp záøí øíj lis pro);
  @MoY2 = @MoY;
  for (@MoY2)
        { s!en$!na! or s!ec$!ce! or s!ad$!adu! or s!or$!ora!; }
  
  @DoW = qw(nedìle pondìlí úterý støeda ètvrtek pátek sobota);
  @DoWs = qw(Ne Po Út St Èt Pá So);
  
  @AMPM = qw(dop. odp.);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_d { $_[0]->[3] }
  sub format_m { $_[0]->[4] + 1 }
  sub format_o { $_[0]->[3] . '.' }
  
  sub format_Q { $MoY2[$_[0]->[4]] }
  
  sub time2str {
        my $ref = shift;
        my @a = @_;
        $a[0] =~ s/(%[do]\.?\s?)%B/$1%Q/;
        $ref->SUPER::time2str(@a);
        }
  
  sub strftime {
        my $ref = shift;
        my @a = @_;
        $a[0] =~ s/(%[do]\.?\s?)%B/$1%Q/;
        $ref->SUPER::time2str(@a);
        }
  
  1;
DATE_LANGUAGE_CZECH

$fatpacked{"Date/Language/Danish.pm"} = <<'DATE_LANGUAGE_DANISH';
  ##
  ## Danish tables
  ##
  
  package Date::Language::Danish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Januar Februar Marts April Maj Juni
  	   Juli August September Oktober November December);
  @MoYs = qw(Jan Feb Mar Apr Maj Jun Jul Aug Sep Okt Nov Dec);
  @DoW  = qw(Søndag Mandag Tirsdag Onsdag Torsdag Fredag Lørdag Søndag);
  @DoWs = qw(Søn Man Tir Ons Tor Fre Lør Søn);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_DANISH

$fatpacked{"Date/Language/Dutch.pm"} = <<'DATE_LANGUAGE_DUTCH';
  ##
  ## Dutch tables
  ## Contributed by Johannes la Poutre <jlpoutre@corp.nl.home.com>
  ##
  
  package Date::Language::Dutch;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.02";
  
  @MoY  = qw(januari februari maart april mei juni juli
             augustus september oktober november december);
  @MoYs = map(substr($_, 0, 3), @MoY);
  $MoYs[2] = 'mrt'; # mrt is more common (Frank Maas)
  @DoW  = map($_ . "dag", qw(zon maan dins woens donder vrij zater));
  @DoWs = map(substr($_, 0, 2), @DoW);
  
  # these aren't normally used...
  @AMPM = qw(VM NM);
  @Dsuf = ('e') x 31;
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_DUTCH

$fatpacked{"Date/Language/English.pm"} = <<'DATE_LANGUAGE_ENGLISH';
  ##
  ## English tables
  ##
  
  package Date::Language::English;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
  @MoY = qw(January February March April May June
  	  July August September October November December);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ENGLISH

$fatpacked{"Date/Language/Finnish.pm"} = <<'DATE_LANGUAGE_FINNISH';
  ##
  ## Finnish tables
  ## Contributed by Matthew Musgrove <muskrat@mindless.com>
  ## Corrected by roke
  ##
  
  package Date::Language::Finnish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  # In Finnish, the names of the months and days are only capitalized at the beginning of sentences.
  @MoY  = map($_ . "kuu", qw(tammi helmi maalis huhti touko kesä heinä elo syys loka marras joulu));
  @DoW  = qw(sunnuntai maanantai tiistai keskiviikko torstai perjantai lauantai);
  
  # it is not customary to use abbreviated names of months or days
  # per Graham's suggestion:
  @MoYs = @MoY;
  @DoWs = @DoW;
  
  # the short form of ordinals
  @Dsuf = ('.') x 31;
  
  # doesn't look like this is normally used...
  @AMPM = qw(ap ip);
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_FINNISH

$fatpacked{"Date/Language/French.pm"} = <<'DATE_LANGUAGE_FRENCH';
  ##
  ## French tables, contributed by Emmanuel Bataille (bem@residents.frmug.org)
  ##
  
  package Date::Language::French;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.04";
  
  @DoW = qw(dimanche lundi mardi mercredi jeudi vendredi samedi);
  @MoY = qw(janvier février mars avril mai juin 
            juillet août septembre octobre novembre décembre);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  $MoYs[6] = 'jul';
  @AMPM = qw(AM PM);
  
  @Dsuf = ((qw(er e e e e e e e e e)) x 3, 'er');
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_FRENCH

$fatpacked{"Date/Language/Gedeo.pm"} = <<'DATE_LANGUAGE_GEDEO';
  ##
  ## Gedeo tables
  ##
  
  package Date::Language::Gedeo;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw( Sanbbattaa Sanno Masano Roobe Hamusse Arbe Qiddamme);
  @MoY = (
  "Oritto",
  "Birre'a",
  "Onkkollessa",
  "Saddasa",
  "Arrasa",
  "Qammo",
  "Ella",
  "Waacibajje",
  "Canissa",
  "Addolessa",
  "Bittitotessa",
  "Hegeya"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  $DoWs[0] = "Snb";
  $DoWs[1] = "Sno";
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(gorsa warreti-udumma);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_GEDEO

$fatpacked{"Date/Language/German.pm"} = <<'DATE_LANGUAGE_GERMAN';
  ##
  ## German tables
  ##
  
  package Date::Language::German;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.02";
  
  @MoY  = qw(Januar Februar März April Mai Juni
  	   Juli August September Oktober November Dezember);
  @MoYs = qw(Jan Feb Mär Apr Mai Jun Jul Aug Sep Okt Nov Dez);
  @DoW  = qw(Sonntag Montag Dienstag Mittwoch Donnerstag Freitag Samstag);
  @DoWs = qw(Son Mon Die Mit Don Fre Sam);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2d.",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_GERMAN

$fatpacked{"Date/Language/Greek.pm"} = <<'DATE_LANGUAGE_GREEK';
  ##
  ## Greek tables
  ##
  ## Traditional date format is: DoW DD{eta} MoY Year (%A %o %B %Y)
  ##
  ## Matthew Musgrove <muskrat@mindless.com>
  ## Translations gratiously provided by Menelaos Stamatelos <men@kwsn.net>
  ## This module returns unicode (utf8) encoded characters.  You will need to
  ## take the necessary steps for this to display correctly.
  ##
  
  package Date::Language::Greek;
  
  use utf8;
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = (
  "\x{039a}\x{03c5}\x{03c1}\x{03b9}\x{03b1}\x{03ba}\x{03ae}",
  "\x{0394}\x{03b5}\x{03c5}\x{03c4}\x{03ad}\x{03c1}\x{03b1}",
  "\x{03a4}\x{03c1}\x{03af}\x{03c4}\x{03b7}",
  "\x{03a4}\x{03b5}\x{03c4}\x{03ac}\x{03c1}\x{03c4}\x{03b7}",
  "\x{03a0}\x{03ad}\x{03bc}\x{03c0}\x{03c4}\x{03b7}",
  "\x{03a0}\x{03b1}\x{03c1}\x{03b1}\x{03c3}\x{03ba}\x{03b5}\x{03c5}\x{03ae}",
  "\x{03a3}\x{03ac}\x{03b2}\x{03b2}\x{03b1}\x{03c4}\x{03bf}",
  );
  
  @MoY = (
  "\x{0399}\x{03b1}\x{03bd}\x{03bf}\x{03c5}\x{03b1}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{03a6}\x{03b5}\x{03b2}\x{03c1}\x{03bf}\x{03c5}\x{03b1}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{039c}\x{03b1}\x{03c1}\x{03c4}\x{03af}\x{03bf}\x{03c5}",
  "\x{0391}\x{03c0}\x{03c1}\x{03b9}\x{03bb}\x{03af}\x{03c5}",
  "\x{039c}\x{03b1}\x{0390}\x{03bf}\x{03c5}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bd}\x{03af}\x{03bf}\x{03c5}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bb}\x{03af}\x{03bf}\x{03c5}",
  "\x{0391}\x{03c5}\x{03b3}\x{03bf}\x{03cd}\x{03c3}\x{03c4}\x{03bf}\x{03c5}",
  "\x{03a3}\x{03b5}\x{03c0}\x{03c4}\x{03b5}\x{03bc}\x{03c4}\x{03bf}\x{03c5}",
  "\x{039f}\x{03ba}\x{03c4}\x{03c9}\x{03b2}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{039d}\x{03bf}\x{03b5}\x{03bc}\x{03b2}\x{03c1}\x{03af}\x{03bf}\x{03c5}",
  "\x{0394}\x{03b5}\x{03ba}\x{03b5}\x{03bc}\x{03b2}\x{03c1}\x{03bf}\x{03c5}",
  );
  
  @DoWs = (
  "\x{039a}\x{03c5}",
  "\x{0394}\x{03b5}",
  "\x{03a4}\x{03c1}",
  "\x{03a4}\x{03b5}",
  "\x{03a0}\x{03b5}",
  "\x{03a0}\x{03b1}",
  "\x{03a3}\x{03b1}",
  );
  @MoYs = (
  "\x{0399}\x{03b1}\x{03bd}",
  "\x{03a6}\x{03b5}",
  "\x{039c}\x{03b1}\x{03c1}",
  "\x{0391}\x{03c0}\x{03c1}",
  "\x{039c}\x{03b1}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bd}",
  "\x{0399}\x{03bf}\x{03c5}\x{03bb}",
  "\x{0391}\x{03c5}\x{03b3}",
  "\x{03a3}\x{03b5}\x{03c0}",
  "\x{039f}\x{03ba}",
  "\x{039d}\x{03bf}",
  "\x{0394}\x{03b5}",
  );
  
  @AMPM = ("\x{03c0}\x{03bc}", "\x{03bc}\x{03bc}");
  
  @Dsuf = ("\x{03b7}" x 31);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_o { sprintf("%2d%s",$_[0]->[3],"\x{03b7}") }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
  
  
  
DATE_LANGUAGE_GREEK

$fatpacked{"Date/Language/Hungarian.pm"} = <<'DATE_LANGUAGE_HUNGARIAN';
  ##
  ## Hungarian tables based on English
  ##
  #
  # This is a just-because-I-stumbled-across-it
  # -and-my-wife-is-Hungarian release: if Graham or
  # someone adds to docs to Date::Format, I'd be
  # glad to correct bugs and extend as neeed.
  #
  
  package Date::Language::Hungarian;
  
  =head1 NAME
  
  Date::Language::Hungarian - Magyar format for Date::Format
  
  =head1 SYNOPSIS
  
  	my $lang = Date::Language->new('Hungarian');
  	print $lang->time2str("%a %b %e %T %Y", time);
  
  	@lt = localtime(time);
  	print $lang->time2str($template, time);
  	print $lang->strftime($template, @lt);
  
  	print $lang->time2str($template, time, $zone);
  	print $lang->strftime($template, @lt, $zone);
  
  	print $lang->ctime(time);
  	print $lang->asctime(@lt);
  
  	print $lang->ctime(time, $zone);
  	print $lang->asctime(@lt, $zone);
  
  See L<Date::Format>.
  
  =head1 AUTHOR
  
  Paula Goddard (paula -at- paulacska -dot- com)
  
  =head1 LICENCE
  
  Made available under the same terms as Perl itself.
  
  =cut
  
  use strict;
  use warnings;
  use base "Date::Language";
  use vars qw( @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  $VERSION = "1.01";
  
  @DoW = qw(Vasárnap Hétfõ Kedd Szerda Csütörtök Péntek Szombat);
  @MoY = qw(Január Február Március Április Május Június
  	  Július Augusztus Szeptember Október November December);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(DE. DU.);
  
  # There is no 'th or 'nd in Hungarian, just a dot
  @Dsuf = (".") x 31;
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_P { lc($_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0]) }
  sub format_o { $_[0]->[3].'.' }
  
  
  
  sub format_D { &format_y . "." . &format_m . "." . &format_d  }
  
  sub format_y { sprintf("%02d",$_[0]->[5] % 100) }
  sub format_d { sprintf("%02d",$_[0]->[3]) }
  sub format_m { sprintf("%02d",$_[0]->[4] + 1) }
  
  
  1;
DATE_LANGUAGE_HUNGARIAN

$fatpacked{"Date/Language/Icelandic.pm"} = <<'DATE_LANGUAGE_ICELANDIC';
  ##
  ## Icelandic tables
  ##
  
  package Date::Language::Icelandic;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Janúar Febrúar Mars Apríl Maí Júni
  	   Júli Ágúst September Október Nóvember Desember);
  @MoYs = qw(Jan Feb Mar Apr Maí Jún Júl Ágú Sep Okt Nóv Des);
  @DoW  = qw(Sunnudagur Mánudagur Þriðjudagur Miðvikudagur Fimmtudagur Föstudagur Laugardagur Sunnudagur);
  @DoWs = qw(Sun Mán Þri Mið Fim Fös Lau Sun);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ICELANDIC

$fatpacked{"Date/Language/Italian.pm"} = <<'DATE_LANGUAGE_ITALIAN';
  ##
  ## Italian tables
  ##
  
  package Date::Language::Italian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Gennaio Febbraio Marzo Aprile Maggio Giugno
  	   Luglio Agosto Settembre Ottobre Novembre Dicembre);
  @MoYs = qw(Gen Feb Mar Apr Mag Giu Lug Ago Set Ott Nov Dic);
  @DoW  = qw(Domenica Lunedi Martedi Mercoledi Giovedi Venerdi Sabato);
  @DoWs = qw(Dom Lun Mar Mer Gio Ven Sab);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ITALIAN

$fatpacked{"Date/Language/Norwegian.pm"} = <<'DATE_LANGUAGE_NORWEGIAN';
  ##
  ## Norwegian tables
  ##
  
  package Date::Language::Norwegian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(Januar Februar Mars April Mai Juni
  	   Juli August September Oktober November Desember);
  @MoYs = qw(Jan Feb Mar Apr Mai Jun Jul Aug Sep Okt Nov Des);
  @DoW  = qw(Søndag Mandag Tirsdag Onsdag Torsdag Fredag Lørdag Søndag);
  @DoWs = qw(Søn Man Tir Ons Tor Fre Lør Søn);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  @Dsuf =   @{Date::Language::English::Dsuf};
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_NORWEGIAN

$fatpacked{"Date/Language/Oromo.pm"} = <<'DATE_LANGUAGE_OROMO';
  ##
  ## Oromo tables
  ##
  
  package Date::Language::Oromo;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Dilbata Wiixata Qibxata Roobii Kamiisa Jimaata Sanbata);
  @MoY = qw(Amajjii Guraandhala Bitooteessa Elba Caamsa Waxabajjii
            Adooleessa Hagayya Fuulbana Onkololeessa Sadaasa Muddee);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(WD WB);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_OROMO

$fatpacked{"Date/Language/Romanian.pm"} = <<'DATE_LANGUAGE_ROMANIAN';
  ##
  ## Italian tables
  ##
  
  package Date::Language::Romanian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(ianuarie februarie martie aprilie mai iunie 
  		iulie august septembrie octombrie noembrie decembrie);
  @DoW  = qw(duminica luni marti miercuri joi vineri sambata);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  
  @AMPM = qw(AM PM);
  
  @Dsuf = ('') x 31;
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_ROMANIAN

$fatpacked{"Date/Language/Russian.pm"} = <<'DATE_LANGUAGE_RUSSIAN';
  ##
  ## Russian tables
  ##
  ## Contributed by Danil Pismenny <dapi@mail.ru>
  
  package Date::Language::Russian;
  
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @MoY2 @AMPM %MoY %DoW $VERSION);
  @ISA = qw(Date::Language Date::Format::Generic);
  $VERSION = "1.01";
  
  @MoY = qw(ñÎ×ÁÒÑ æÅ×ÒÁÌÑ íÁÒÔÁ áÐÒÅÌÑ íÁÑ éÀÎÑ éÀÌÑ á×ÇÕÓÔÁ óÅÎÔÑÂÒÑ ïËÔÑÂÒÑ îÏÑÂÒÑ äÅËÁÂÒÑ);
  @MoY2 = qw(ñÎ×ÁÒØ æÅ×ÒÁÌØ íÁÒÔ áÐÒÅÌØ íÁÊ éÀÎØ éÀÌØ á×ÇÕÓÔ óÅÎÔÑÂÒØ ïËÔÑÂÒØ îÏÑÂÒØ äÅËÁÂÒØ);
  @MoYs = qw(ñÎ× æÅ× íÒÔ áÐÒ íÁÊ éÀÎ éÀÌ á×Ç óÅÎ ïËÔ îÏÑ äÅË);
  
  @DoW = qw(ðÏÎÅÄÅÌØÎÉË ÷ÔÏÒÎÉË óÒÅÄÁ þÅÔ×ÅÒÇ ðÑÔÎÉÃÁ óÕÂÂÏÔÁ ÷ÏÓËÒÅÓÅÎØÅ);
  @DoWs = qw(ðÎ ÷Ô óÒ þÔ ðÔ óÂ ÷Ó);
  @DoWs2 = qw(ðÎÄ ÷ÔÒ óÒÄ þÔ× ðÔÎ óÂÔ ÷ÓË);
  
  @AMPM = qw(ÄÐ ÐÐ);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  sub format_d { $_[0]->[3] }
  sub format_m { $_[0]->[4] + 1 }
  sub format_o { $_[0]->[3] . '.' }
  
  sub format_Q { $MoY2[$_[0]->[4]] }
  
  sub str2time {
    my ($self,$value) = @_;
    map {$value=~s/(\s|^)$DoWs2[$_](\s)/$DoWs[$_]$2/ig} (0..6);
    $value=~s/(\s+|^)íÁÒ(\s+)/$1íÒÔ$2/;
    return $self->SUPER::str2time($value);
  }
  
  1;
DATE_LANGUAGE_RUSSIAN

$fatpacked{"Date/Language/Russian_cp1251.pm"} = <<'DATE_LANGUAGE_RUSSIAN_CP1251';
  ##
  ## Russian cp1251
  ##
  
  package Date::Language::Russian_cp1251;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(Âîñêðåñåíüå Ïîíåäåëüíèê Âòîðíèê Ñðåäà ×åòâåðã Ïÿòíèöà Ñóááîòà);
  @MoY = qw(ßíâàðü Ôåâðàëü Ìàðò Àïðåëü Ìàé Èþíü
        Èþëü Àâãóñò Ñåíòÿáðü Îêòÿáðü Íîÿáðü Äåêàáðü);
  @DoWs = qw(Âñê Ïíä Âòð Ñðä ×òâ Ïòí Ñáò);
  #@DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = ('e') x 31;
  #@Dsuf[11,12,13] = qw(å å å);
  #@Dsuf[30,31] = qw(å å);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_RUSSIAN_CP1251

$fatpacked{"Date/Language/Russian_koi8r.pm"} = <<'DATE_LANGUAGE_RUSSIAN_KOI8R';
  ##
  ## Russian koi8r
  ##
  
  package Date::Language::Russian_koi8r;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @DoW = qw(÷ÏÓËÒÅÓÅÎØÅ ðÏÎÅÄÅÌØÎÉË ÷ÔÏÒÎÉË óÒÅÄÁ þÅÔ×ÅÒÇ ðÑÔÎÉÃÁ óÕÂÂÏÔÁ);
  @MoY = qw(ñÎ×ÁÒØ æÅ×ÒÁÌØ íÁÒÔ áÐÒÅÌØ íÁÊ éÀÎØ
        éÀÌØ á×ÇÕÓÔ óÅÎÔÑÂÒØ ïËÔÑÂÒØ îÏÑÂÒØ äÅËÁÂÒØ);
  @DoWs = qw(÷ÓË ðÎÄ ÷ÔÒ óÒÄ þÔ× ðÔÎ óÂÔ);
  #@DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = ('e') x 31;
  #@Dsuf[11,12,13] = qw(Å Å Å);
  #@Dsuf[30,31] = qw(Å Å);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_RUSSIAN_KOI8R

$fatpacked{"Date/Language/Sidama.pm"} = <<'DATE_LANGUAGE_SIDAMA';
  ##
  ## Sidama tables
  ##
  
  package Date::Language::Sidama;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Sambata Sanyo Maakisanyo Roowe Hamuse Arbe Qidaame);
  @MoY = qw(January February March April May June
            July August September October November December);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(soodo hawwaro);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_SIDAMA

$fatpacked{"Date/Language/Somali.pm"} = <<'DATE_LANGUAGE_SOMALI';
  ##
  ## Somali tables
  ##
  
  package Date::Language::Somali;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "0.99";
  
  @DoW = qw(Axad Isniin Salaaso Arbaco Khamiis Jimco Sabti);
  @MoY = (
  "Bisha Koobaad",
  "Bisha Labaad",
  "Bisha Saddexaad",
  "Bisha Afraad",
  "Bisha Shanaad",
  "Bisha Lixaad",
  "Bisha Todobaad",
  "Bisha Sideedaad",
  "Bisha Sagaalaad",
  "Bisha Tobnaad",
  "Bisha Kow iyo Tobnaad",
  "Bisha Laba iyo Tobnaad"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = (
  "Kob",
  "Lab",
  "Sad",
  "Afr",
  "Sha",
  "Lix",
  "Tod",
  "Sid",
  "Sag",
  "Tob",
  "KIT",
  "LIT"
  );
  @AMPM = qw(SN GN);
  
  @Dsuf = (qw(th st nd rd th th th th th th)) x 3;
  @Dsuf[11,12,13] = qw(th th th);
  @Dsuf[30,31] = qw(th st);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_SOMALI

$fatpacked{"Date/Language/Spanish.pm"} = <<'DATE_LANGUAGE_SPANISH';
  ##
  ## Spanish tables
  ##
  
  package Date::Language::Spanish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = qw(domingo lunes martes miércoles jueves viernes sábado);
  @MoY = qw(enero febrero marzo abril mayo junio
  	  julio agosto septiembre octubre noviembre diciembre);
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = qw(AM PM);
  
  @Dsuf = ((qw(ro do ro to to to mo vo no mo)) x 3, 'ro');
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_SPANISH

$fatpacked{"Date/Language/Swedish.pm"} = <<'DATE_LANGUAGE_SWEDISH';
  ##
  ## Swedish tables
  ## Contributed by Matthew Musgrove <muskrat@mindless.com>
  ## Corrected by dempa
  ##
  
  package Date::Language::Swedish;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.01";
  
  @MoY  = qw(januari februari mars april maj juni juli augusti september oktober november december);
  @MoYs = map { substr($_,0,3) } @MoY;
  @DoW  = map($_ . "dagen", qw(sön mån tis ons tors fre lör));
  @DoWs = map { substr($_,0,2) } @DoW;
  
  # the ordinals are not typically used in modern times
  @Dsuf = ('a' x 2, 'e' x 29);
  
  use Date::Language::English ();
  @AMPM =   @{Date::Language::English::AMPM};
  
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  sub format_o { sprintf("%2de",$_[0]->[3]) }
  
  1;
DATE_LANGUAGE_SWEDISH

$fatpacked{"Date/Language/Tigrinya.pm"} = <<'DATE_LANGUAGE_TIGRINYA';
  ##
  ## Tigrinya tables
  ##
  
  package Date::Language::Tigrinya;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  @DoW = (
  "\x{1230}\x{1295}\x{1260}\x{1275}",
  "\x{1230}\x{1291}\x{12ed}",
  "\x{1230}\x{1209}\x{1235}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1213}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1262}",
  "\x{1240}\x{12f3}\x{121d}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = (
  "\x{1295}/\x{1230}",
  "\x{12F5}/\x{1230}"
  );
  
  @Dsuf = ("\x{12ed}" x 31);
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_TIGRINYA

$fatpacked{"Date/Language/TigrinyaEritrean.pm"} = <<'DATE_LANGUAGE_TIGRINYAERITREAN';
  ##
  ## Tigrinya-Eritrean tables
  ##
  
  package Date::Language::TigrinyaEritrean;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  if ( $] >= 5.006 ) {
  @DoW = (
  "\x{1230}\x{1295}\x{1260}\x{1275}",
  "\x{1230}\x{1291}\x{12ed}",
  "\x{1230}\x{1209}\x{1235}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1213}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1262}",
  "\x{1240}\x{12f3}\x{121d}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = (
  "\x{1295}/\x{1230}",
  "\x{12F5}/\x{1230}"
  );
  
  @Dsuf = ("\x{12ed}" x 31);
  }
  else {
  @DoW = (
  "áˆ°áŠ•á‰ á‰µ",
  "áˆ°áŠ‘á‹­",
  "áˆ°áˆ‰áˆµ",
  "áˆ¨á‰¡á‹•",
  "áˆ“áˆ™áˆµ",
  "á‹“áˆ­á‰¢",
  "á‰€á‹³áˆ"
  );
  @MoY = (
  "áŒ¥áˆª",
  "áˆˆáŠ«á‰²á‰µ",
  "áˆ˜áŒ‹á‰¢á‰µ",
  "áˆšá‹«á‹á‹«",
  "áŒáŠ•á‰¦á‰µ",
  "áˆ°áŠ",
  "áˆ“áˆáˆˆ",
  "áŠáˆ“áˆ°",
  "áˆ˜áˆµáŠ¨áˆ¨áˆ",
  "áŒ¥á‰…áˆá‰²",
  "áˆ•á‹³áˆ­",
  "á‰³áˆ•áˆ³áˆµ"
  );
  @DoWs = map { substr($_,0,9) } @DoW;
  @MoYs = map { substr($_,0,9) } @MoY;
  @AMPM = (
  "áŠ•/áˆ°",
  "á‹µ/áˆ°"
  );
  
  @Dsuf = ("á‹­" x 31);
  }
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_TIGRINYAERITREAN

$fatpacked{"Date/Language/TigrinyaEthiopian.pm"} = <<'DATE_LANGUAGE_TIGRINYAETHIOPIAN';
  ##
  ## Tigrinya-Ethiopian tables
  ##
  
  package Date::Language::TigrinyaEthiopian;
  
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION);
  @ISA = qw(Date::Language);
  $VERSION = "1.00";
  
  if ( $] >= 5.006 ) {
  @DoW = (
  "\x{1230}\x{1295}\x{1260}\x{1275}",
  "\x{1230}\x{1291}\x{12ed}",
  "\x{1230}\x{1209}\x{1235}",
  "\x{1228}\x{1261}\x{12d5}",
  "\x{1213}\x{1219}\x{1235}",
  "\x{12d3}\x{122d}\x{1262}",
  "\x{1240}\x{12f3}\x{121d}"
  );
  @MoY = (
  "\x{1303}\x{1295}\x{12e9}\x{12c8}\x{122a}",
  "\x{134c}\x{1265}\x{1229}\x{12c8}\x{122a}",
  "\x{121b}\x{122d}\x{127d}",
  "\x{12a4}\x{1355}\x{1228}\x{120d}",
  "\x{121c}\x{12ed}",
  "\x{1301}\x{1295}",
  "\x{1301}\x{120b}\x{12ed}",
  "\x{12a6}\x{1308}\x{1235}\x{1275}",
  "\x{1234}\x{1355}\x{1274}\x{121d}\x{1260}\x{122d}",
  "\x{12a6}\x{12ad}\x{1270}\x{12cd}\x{1260}\x{122d}",
  "\x{1296}\x{126c}\x{121d}\x{1260}\x{122d}",
  "\x{12f2}\x{1234}\x{121d}\x{1260}\x{122d}"
  );
  @DoWs = map { substr($_,0,3) } @DoW;
  @MoYs = map { substr($_,0,3) } @MoY;
  @AMPM = (
  "\x{1295}/\x{1230}",
  "\x{12F5}/\x{1230}"
  );
  
  @Dsuf = ("\x{12ed}" x 31);
  }
  else {
  @DoW = (
  "áˆ°áŠ•á‰ á‰µ",
  "áˆ°áŠ‘á‹­",
  "áˆ°áˆ‰áˆµ",
  "áˆ¨á‰¡á‹•",
  "áˆ“áˆ™áˆµ",
  "á‹“áˆ­á‰¢",
  "á‰€á‹³áˆ"
  );
  @MoY = (
  "áŒƒáŠ•á‹©á‹ˆáˆª",
  "áŒá‰¥áˆ©á‹ˆáˆª",
  "áˆ›áˆ­á‰½",
  "áŠ¤á•áˆ¨áˆ",
  "áˆœá‹­",
  "áŒáŠ•",
  "áŒáˆ‹á‹­",
  "áŠ¦áŒˆáˆµá‰µ",
  "áˆ´á•á‰´áˆá‰ áˆ­",
  "áŠ¦áŠ­á‰°á‹á‰ áˆ­",
  "áŠ–á‰¬áˆá‰ áˆ­",
  "á‹²áˆ´áˆá‰ áˆ­"
  );
  @DoWs = map { substr($_,0,9) } @DoW;
  @MoYs = map { substr($_,0,9) } @MoY;
  @AMPM = (
  "áŠ•/áˆ°",
  "á‹µ/áˆ°"
  );
  
  @Dsuf = ("á‹­" x 31);
  }
  
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[$_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[$_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { $_[0]->[2] >= 12 ?  $AMPM[1] : $AMPM[0] }
  
  1;
DATE_LANGUAGE_TIGRINYAETHIOPIAN

$fatpacked{"Date/Language/Turkish.pm"} = <<'DATE_LANGUAGE_TURKISH';
  #----------------------------------------------------#
  #
  # Turkish tables
  # Burak Gürsoy <burak@cpan.org>
  # Last modified: Sat Nov 15 20:28:32 2003
  #
  # use Date::Language;
  # my $turkish = Date::Language->new('Turkish');
  # print $turkish->time2str("%e %b %Y, %a %T\n", time);
  # print $turkish->str2time("25 Haz 1996 21:09:55 +0100");
  #----------------------------------------------------#
  
  package Date::Language::Turkish;
  use Date::Language ();
  use vars qw(@ISA @DoW @DoWs @MoY @MoYs @AMPM @Dsuf %MoY %DoW $VERSION %DsufMAP);
  @ISA     = qw(Date::Language);
  $VERSION = "1.0";
  
  @DoW = qw(Pazar Pazartesi Salý Çarþamba Perþembe Cuma Cumartesi);
  @MoY = qw(Ocak Þubat Mart  Nisan Mayýs Haziran Temmuz Aðustos Eylül Ekim Kasým Aralýk);
  @DoWs     = map { substr($_,0,3) } @DoW;
  $DoWs[1]  = 'Pzt'; # Since we'll get two 'Paz' s
  $DoWs[-1] = 'Cmt'; # Since we'll get two 'Cum' s
  @MoYs     = map { substr($_,0,3) } @MoY;
  @AMPM     = ('',''); # no am-pm thingy
  
  # not easy as in english... maybe we can just use a dot "." ? :)
  %DsufMAP = (
  (map {$_ => 'inci', $_+10 => 'inci', $_+20 => 'inci' } 1,2,5,8 ),
  (map {$_ =>  'nci', $_+10 =>  'nci', $_+20 =>  'nci' } 7       ),
  (map {$_ =>  'nci', $_+10 =>  'nci', $_+20 =>  'nci' } 2       ),
  (map {$_ => 'üncü', $_+10 => 'üncü', $_+20 => 'üncü' } 3,4     ),
  (map {$_ => 'uncu', $_+10 => 'uncu', $_+20 => 'uncu' } 9       ),
  (map {$_ =>  'ncý', $_+10 =>  'ncý', $_+20 =>  'ncý' } 6       ),
  (map {$_ => 'uncu',                                  } 10,30   ),
        20 =>  'nci',
        31 => 'inci',
  );
  
  @Dsuf       = map{ $DsufMAP{$_} } sort {$a <=> $b} keys %DsufMAP;
  @MoY{@MoY}  = (0 .. scalar(@MoY));
  @MoY{@MoYs} = (0 .. scalar(@MoYs));
  @DoW{@DoW}  = (0 .. scalar(@DoW));
  @DoW{@DoWs} = (0 .. scalar(@DoWs));
  
  # Formatting routines
  
  sub format_a { $DoWs[$_[0]->[6]] }
  sub format_A { $DoW[ $_[0]->[6]] }
  sub format_b { $MoYs[$_[0]->[4]] }
  sub format_B { $MoY[ $_[0]->[4]] }
  sub format_h { $MoYs[$_[0]->[4]] }
  sub format_p { '' } # disable
  sub format_P { '' } # disable
  sub format_o { sprintf("%2d%s",$_[0]->[3],$Dsuf[$_[0]->[3]-1]) }
  
  1;
  
  __END__
DATE_LANGUAGE_TURKISH

$fatpacked{"Date/Parse.pm"} = <<'DATE_PARSE';
  # Copyright (c) 1995-2009 Graham Barr. This program is free
  # software; you can redistribute it and/or modify it under the same terms
  # as Perl itself.
  
  package Date::Parse;
  
  require 5.000;
  use strict;
  use vars qw($VERSION @ISA @EXPORT);
  use Time::Local;
  use Carp;
  use Time::Zone;
  use Exporter;
  
  @ISA = qw(Exporter);
  @EXPORT = qw(&strtotime &str2time &strptime);
  
  $VERSION = "2.30";
  
  my %month = (
  	january		=> 0,
  	february	=> 1,
  	march		=> 2,
  	april		=> 3,
  	may		=> 4,
  	june		=> 5,
  	july		=> 6,
  	august		=> 7,
  	september	=> 8,
  	sept		=> 8,
  	october		=> 9,
  	november	=> 10,
  	december	=> 11,
  	);
  
  my %day = (
  	sunday		=> 0,
  	monday		=> 1,
  	tuesday		=> 2,
  	tues		=> 2,
  	wednesday	=> 3,
  	wednes		=> 3,
  	thursday	=> 4,
  	thur		=> 4,
  	thurs		=> 4,
  	friday		=> 5,
  	saturday	=> 6,
  	);
  
  my @suf = (qw(th st nd rd th th th th th th)) x 3;
  @suf[11,12,13] = qw(th th th);
  
  #Abbreviations
  
  map { $month{substr($_,0,3)} = $month{$_} } keys %month;
  map { $day{substr($_,0,3)}   = $day{$_} }   keys %day;
  
  my $strptime = <<'ESQ';
   my %month = map { lc $_ } %$mon_ref;
   my $daypat = join("|", map { lc $_ } reverse sort keys %$day_ref);
   my $monpat = join("|", reverse sort keys %month);
   my $sufpat = join("|", reverse sort map { lc $_ } @$suf_ref);
  
   my %ampm = (
  	'a' => 0,  # AM
  	'p' => 12, # PM
  	);
  
   my($AM, $PM) = (0,12);
  
  sub {
  
    my $dtstr = lc shift;
    my $merid = 24;
  
    my($year,$month,$day,$hh,$mm,$ss,$zone,$dst,$frac);
  
    $zone = tz_offset(shift) if @_;
  
    1 while $dtstr =~ s#\([^\(\)]*\)# #o;
  
    $dtstr =~ s#(\A|\n|\Z)# #sog;
  
    # ignore day names
    $dtstr =~ s#([\d\w\s])[\.\,]\s#$1 #sog;
    $dtstr =~ s/,/ /g;
    $dtstr =~ s#($daypat)\s*(den\s)?\b# #o;
    # Time: 12:00 or 12:00:00 with optional am/pm
  
    return unless $dtstr =~ /\S/;
    
    if ($dtstr =~ s/\s(\d{4})([-:]?)(\d\d?)\2(\d\d?)(?:[-Tt ](\d\d?)(?:([-:]?)(\d\d?)(?:\6(\d\d?)(?:[.,](\d+))?)?)?)?(?=\D)/ /) {
      ($year,$month,$day,$hh,$mm,$ss,$frac) = ($1,$3-1,$4,$5,$7,$8,$9);
    }
  
    unless (defined $hh) {
      if ($dtstr =~ s#[:\s](\d\d?):(\d\d?)(:(\d\d?)(?:\.\d+)?)?(z)?\s*(?:([ap])\.?m?\.?)?\s# #o) {
        ($hh,$mm,$ss) = ($1,$2,$4);
        $zone = 0 if $5;
        $merid = $ampm{$6} if $6;
      }
  
      # Time: 12 am
      
      elsif ($dtstr =~ s#\s(\d\d?)\s*([ap])\.?m?\.?\s# #o) {
        ($hh,$mm,$ss) = ($1,0,0);
        $merid = $ampm{$2};
      }
    }
      
    if (defined $hh and $hh <= 12 and $dtstr =~ s# ([ap])\.?m?\.?\s# #o) {
      $merid = $ampm{$1};
    }
  
  
    unless (defined $year) {
      # Date: 12-June-96 (using - . or /)
      
      if ($dtstr =~ s#\s(\d\d?)([\-\./])($monpat)(\2(\d\d+))?\s# #o) {
        ($month,$day) = ($month{$3},$1);
        $year = $5 if $5;
      }
      
      # Date: 12-12-96 (using '-', '.' or '/' )
      
      elsif ($dtstr =~ s#\s(\d+)([\-\./])(\d\d?)(\2(\d+))?\s# #o) {
        ($month,$day) = ($1 - 1,$3);
  
        if ($5) {
  	$year = $5;
  	# Possible match for 1995-01-24 (short mainframe date format);
  	($year,$month,$day) = ($1, $3 - 1, $5) if $month > 12;
  	return if length($year) > 2 and $year < 1901;
        }
      }
      elsif ($dtstr =~ s#\s(\d+)\s*($sufpat)?\s*($monpat)# #o) {
        ($month,$day) = ($month{$3},$1);
      }
      elsif ($dtstr =~ s#($monpat)\s*(\d+)\s*($sufpat)?\s# #o) {
        ($month,$day) = ($month{$1},$2);
      }
      elsif ($dtstr =~ s#($monpat)([\/-])(\d+)[\/-]# #o) {
        ($month,$day) = ($month{$1},$3);
      }
  
      # Date: 961212
  
      elsif ($dtstr =~ s#\s(\d\d)(\d\d)(\d\d)\s# #o) {
        ($year,$month,$day) = ($1,$2-1,$3);
      }
  
      $year = $1 if !defined($year) and $dtstr =~ s#\s(\d{2}(\d{2})?)[\s\.,]# #o;
  
    }
  
    # Zone
  
    $dst = 1 if $dtstr =~ s#\bdst\b##o;
  
    if ($dtstr =~ s#\s"?([a-z]{3,4})(dst|\d+[a-z]*|_[a-z]+)?"?\s# #o) {
      $dst = 1 if $2 and $2 eq 'dst';
      $zone = tz_offset($1);
      return unless defined $zone;
    }
    elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?):?(\d\d)?(00)?\s# #o) {
      my $m = defined($4) ? "$2$4" : 0;
      my $h = "$2$3";
      $zone = defined($1) ? tz_offset($1) : 0;
      return unless defined $zone;
      $zone += 60 * ($m + (60 * $h));
    }
  
    if ($dtstr =~ /\S/) {
      # now for some dumb dates
      if ($dtstr =~ s/^\s*(ut?|z)\s*$//) {
        $zone = 0;
      }
      elsif ($dtstr =~ s#\s([a-z]{3,4})?([\-\+]?)-?(\d\d?)(\d\d)?(00)?\s# #o) {
        my $m = defined($4) ? "$2$4" : 0;
        my $h = "$2$3";
        $zone = defined($1) ? tz_offset($1) : 0;
        return unless defined $zone;
        $zone += 60 * ($m + (60 * $h));
      }
  
      return if $dtstr =~ /\S/o;
    }
  
    if (defined $hh) {
      if ($hh == 12) {
        $hh = 0 if $merid == $AM;
      }
      elsif ($merid == $PM) {
        $hh += 12;
      }
    }
  
    $year -= 1900 if defined $year && $year > 1900;
  
    $zone += 3600 if defined $zone && $dst;
    $ss += "0.$frac" if $frac;
  
    return ($ss,$mm,$hh,$day,$month,$year,$zone);
  }
  ESQ
  
  use vars qw($day_ref $mon_ref $suf_ref $obj);
  
  sub gen_parser
  {
   local($day_ref,$mon_ref,$suf_ref,$obj) = @_;
  
   if($obj)
    {
     my $obj_strptime = $strptime;
     substr($obj_strptime,index($strptime,"sub")+6,0) = <<'ESQ';
   shift; # package
  ESQ
     my $sub = eval "$obj_strptime" or die $@;
     return $sub;
    }
  
   eval "$strptime" or die $@;
  
  }
  
  *strptime = gen_parser(\%day,\%month,\@suf);
  
  sub str2time
  {
   my @t = strptime(@_);
  
   return undef
  	unless @t;
  
   my($ss,$mm,$hh,$day,$month,$year,$zone) = @t;
   my @lt  = localtime(time);
  
   $hh    ||= 0;
   $mm    ||= 0;
   $ss    ||= 0;
  
   my $frac = $ss - int($ss);
   $ss = int $ss;
  
   $month = $lt[4]
  	unless(defined $month);
  
   $day  = $lt[3]
  	unless(defined $day);
  
   $year = ($month > $lt[4]) ? ($lt[5] - 1) : $lt[5]
  	unless(defined $year);
  
   return undef
  	unless($month <= 11 && $day >= 1 && $day <= 31
  		&& $hh <= 23 && $mm <= 59 && $ss <= 59);
  
   my $result;
  
   if (defined $zone) {
     $result = eval {
       local $SIG{__DIE__} = sub {}; # Ick!
       timegm($ss,$mm,$hh,$day,$month,$year);
     };
     return undef
       if !defined $result
          or $result == -1
             && join("",$ss,$mm,$hh,$day,$month,$year)
       	        ne "595923311169";
     $result -= $zone;
   }
   else {
     $result = eval {
       local $SIG{__DIE__} = sub {}; # Ick!
       timelocal($ss,$mm,$hh,$day,$month,$year);
     };
     return undef
       if !defined $result
          or $result == -1
             && join("",$ss,$mm,$hh,$day,$month,$year)
       	        ne join("",(localtime(-1))[0..5]);
   }
  
   return $result + $frac;
  }
  
  1;
  
  __END__
  
  
  =head1 NAME
  
  Date::Parse - Parse date strings into time values
  
  =head1 SYNOPSIS
  
  	use Date::Parse;
  	
  	$time = str2time($date);
  	
  	($ss,$mm,$hh,$day,$month,$year,$zone) = strptime($date);
  
  =head1 DESCRIPTION
  
  C<Date::Parse> provides two routines for parsing date strings into time values.
  
  =over 4
  
  =item str2time(DATE [, ZONE])
  
  C<str2time> parses C<DATE> and returns a unix time value, or undef upon failure.
  C<ZONE>, if given, specifies the timezone to assume when parsing if the
  date string does not specify a timezone.
  
  =item strptime(DATE [, ZONE])
  
  C<strptime> takes the same arguments as str2time but returns an array of
  values C<($ss,$mm,$hh,$day,$month,$year,$zone)>. Elements are only defined
  if they could be extracted from the date string. The C<$zone> element is
  the timezone offset in seconds from GMT. An empty array is returned upon
  failure.
  
  =head1 MULTI-LANGUAGE SUPPORT
  
  Date::Parse is capable of parsing dates in several languages, these include
  English, French, German and Italian.
  
  	$lang = Date::Language->new('German');
  	$lang->str2time("25 Jun 1996 21:09:55 +0100");
  
  =head1 EXAMPLE DATES
  
  Below is a sample list of dates that are known to be parsable with Date::Parse
  
   1995:01:24T09:08:17.1823213           ISO-8601
   1995-01-24T09:08:17.1823213
   Wed, 16 Jun 94 07:29:35 CST           Comma and day name are optional 
   Thu, 13 Oct 94 10:13:13 -0700
   Wed, 9 Nov 1994 09:50:32 -0500 (EST)  Text in ()'s will be ignored.
   21 dec 17:05                          Will be parsed in the current time zone
   21-dec 17:05
   21/dec 17:05
   21/dec/93 17:05
   1999 10:02:18 "GMT"
   16 Nov 94 22:28:20 PST 
  
  =head1 LIMITATION
  
  Date::Parse uses L<Time::Local> internally, so is limited to only parsing dates
  which result in valid values for Time::Local::timelocal. This generally means dates
  between 1901-12-17 00:00:00 GMT and 2038-01-16 23:59:59 GMT
  
  =head1 BUGS
  
  When both the month and the date are specified in the date as numbers
  they are always parsed assuming that the month number comes before the
  date. This is the usual format used in American dates.
  
  The reason why it is like this and not dynamic is that it must be
  deterministic. Several people have suggested using the current locale,
  but this will not work as the date being parsed may not be in the format
  of the current locale.
  
  My plans to address this, which will be in a future release, is to allow
  the programmer to state what order they want these values parsed in.
  
  =head1 AUTHOR
  
  Graham Barr <gbarr@pobox.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1995-2009 Graham Barr. This program is free
  software; you can redistribute it and/or modify it under the same terms
  as Perl itself.
  
  =cut
  
DATE_PARSE

$fatpacked{"Time/CTime.pm"} = <<'TIME_CTIME';
  package Time::CTime;
  
  
  require 5.000;
  
  use Time::Timezone;
  use Time::CTime;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(ctime asctime strftime);
  @EXPORT_OK = qw(asctime_n ctime_n @DoW @MoY @DayOfWeek @MonthOfYear);
  
  use strict;
  
  # constants
  use vars qw(@DoW @DayOfWeek @MoY @MonthOfYear %strftime_conversion $VERSION);
  use vars qw($template $sec $min $hour $mday $mon $year $wday $yday $isdst);
  
  $VERSION = 2011.0505;
  
  CONFIG: {
      @DoW = 	   qw(Sun Mon Tue Wed Thu Fri Sat);
      @DayOfWeek =   qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday);
      @MoY = 	   qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
      @MonthOfYear = qw(January February March April May June 
  		      July August September October November December);
    
      %strftime_conversion = (
  	'%',	sub { '%' },
  	'a',	sub { $DoW[$wday] },
  	'A',	sub { $DayOfWeek[$wday] },
  	'b',	sub { $MoY[$mon] },
  	'B',	sub { $MonthOfYear[$mon] },
  	'c',	sub { asctime_n($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst, "") },
  	'd',	sub { sprintf("%02d", $mday); },
  	'D',	sub { sprintf("%02d/%02d/%02d", $mon+1, $mday, $year%100) },
  	'e',	sub { sprintf("%2d", $mday); },
  	'f',	sub { fracprintf ("%3.3f", $sec); },
  	'F',	sub { fracprintf ("%6.6f", $sec); },
  	'h',	sub { $MoY[$mon] },
  	'H',	sub { sprintf("%02d", $hour) },
  	'I',	sub { sprintf("%02d", $hour % 12 || 12) },
  	'j',	sub { sprintf("%03d", $yday + 1) },
  	'k',	sub { sprintf("%2d", $hour); },
  	'l',	sub { sprintf("%2d", $hour % 12 || 12) },
  	'm',	sub { sprintf("%02d", $mon+1); },
  	'M',	sub { sprintf("%02d", $min) },
  	'n',	sub { "\n" },
  	'o',	sub { sprintf("%d%s", $mday, (($mday < 20 && $mday > 3) ? 'th' : ($mday%10 == 1 ? "st" : ($mday%10 == 2 ? "nd" : ($mday%10 == 3 ? "rd" : "th"))))) },
  	'p',	sub { $hour > 11 ? "PM" : "AM" },
  	'r',	sub { sprintf("%02d:%02d:%02d %s", $hour % 12 || 12, $min, $sec, $hour > 11 ? 'PM' : 'AM') },
  	'R',	sub { sprintf("%02d:%02d", $hour, $min) },
  	'S',	sub { sprintf("%02d", $sec) },
  	't',	sub { "\t" },
  	'T',	sub { sprintf("%02d:%02d:%02d", $hour, $min, $sec) },
  	'U',	sub { wkyr(0, $wday, $yday) },
  	'v',	sub { sprintf("%2d-%s-%4d", $mday, $MoY[$mon], $year+1900) },
  	'w',	sub { $wday },
  	'W',	sub { wkyr(1, $wday, $yday) },
  	'y',	sub { sprintf("%02d",$year%100) },
  	'Y',	sub { $year + 1900 },
  	'x',	sub { sprintf("%02d/%02d/%02d", $mon + 1, $mday, $year%100) },
  	'X',	sub { sprintf("%02d:%02d:%02d", $hour, $min, $sec) },
  	'Z',	sub { &tz2zone(undef,undef,$isdst) }
  	# z sprintf("%+03d%02d", $offset / 3600, ($offset % 3600)/60);
      );
  
  
  }
  
  sub fracprintf {
      my($t,$s) = @_;
      my($p) = sprintf($t, $s-int($s));
      $p=~s/^0+//;
      $p;
  }
  
  sub asctime_n {
      my($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst, $TZname) = @_;
      ($sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst, $TZname) = localtime($sec) unless defined $min;
      $year += 1900;
      $TZname .= ' ' 
  	if $TZname;
      sprintf("%s %s %2d %2d:%02d:%02d %s%4d",
  	  $DoW[$wday], $MoY[$mon], $mday, $hour, $min, $sec, $TZname, $year);
  }
  
  sub asctime
  {
      return asctime_n(@_)."\n";
  }
  
  # is this formula right?
  sub wkyr {
      my($wstart, $wday, $yday) = @_;
      $wday = ($wday + 7 - $wstart) % 7;
      return int(($yday - $wday + 13) / 7 - 1);
  }
  
  # ctime($time)
  
  sub ctime {
      my($time) = @_;
      asctime(localtime($time), &tz2zone(undef,$time));
  }
  
  sub ctime_n {
      my($time) = @_;
      asctime_n(localtime($time), &tz2zone(undef,$time));
  }
  
  # strftime($template, @time_struct)
  #
  # Does not support locales
  
  sub strftime {			
      local ($template, $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst) = @_;
  
      undef $@;
      $template =~ s/%([%aAbBcdDefFhHIjklmMnopQrRStTUvwWxXyYZ])/&{$Time::CTime::strftime_conversion{$1}}()/egs;
      die $@ if $@;
      return $template;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::CTime -- format times ala POSIX asctime
  
  =head1 SYNOPSIS
  
  	use Time::CTime
   	print ctime(time);
  	print asctime(localtime(time));
  	print strftime(template, localtime(time)); 
  
  =head2 strftime conversions
  
  	%%	PERCENT
  	%a	day of the week abbr
  	%A	day of the week
  	%b	month abbr
  	%B 	month
  	%c 	ctime format: Sat Nov 19 21:05:57 1994
  	%d 	DD
  	%D 	MM/DD/YY
  	%e 	numeric day of the month
  	%f 	floating point seconds (milliseconds): .314
  	%F 	floating point seconds (microseconds): .314159
  	%h 	month abbr
  	%H 	hour, 24 hour clock, leading 0's)
  	%I 	hour, 12 hour clock, leading 0's)
  	%j 	day of the year
  	%k 	hour
  	%l 	hour, 12 hour clock
  	%m 	month number, starting with 1, leading 0's
  	%M 	minute, leading 0's
  	%n 	NEWLINE
  	%o	ornate day of month -- "1st", "2nd", "25th", etc.
  	%p 	AM or PM 
  	%r 	time format: 09:05:57 PM
  	%R 	time format: 21:05
  	%S 	seconds, leading 0's
  	%t 	TAB
  	%T 	time format: 21:05:57
  	%U 	week number, Sunday as first day of week
  	%v	DD-Mon-Year
  	%w 	day of the week, numerically, Sunday == 0
  	%W 	week number, Monday as first day of week
  	%x 	date format: 11/19/94
  	%X 	time format: 21:05:57
  	%y	year (2 digits)
  	%Y	year (4 digits)
  	%Z 	timezone in ascii. eg: PST
  
  =head1 DESCRIPTION
  
  This module provides routines to format dates.  They correspond 
  to the libc routines.  &strftime() supports a pretty good set of
  coversions -- more than most C libraries.
   
  strftime supports a pretty good set of conversions.  
  
  The POSIX module has very similar functionality.  You should consider
  using it instead if you do not have allergic reactions to system 
  libraries.
  
  =head1 GENESIS
  
  Written by David Muir Sharnoff <muir@idiom.org>.
  
  The starting point for this package was a posting by 
  Paul Foley <paul@ascent.com> 
  
  =head1 LICENSE
  
  Copyright (C) 1996-2010 David Muir Sharnoff.  
  Copyright (C) 2011 Google, Inc.  
  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
  
TIME_CTIME

$fatpacked{"Time/DaysInMonth.pm"} = <<'TIME_DAYSINMONTH';
  package Time::DaysInMonth;
  
  use Carp;
  
  require 5.000;
  
  @ISA = qw(Exporter);
  @EXPORT = qw(days_in is_leap);
  @EXPORT_OK = qw(%mltable);
  
  use strict;
  
  use vars qw($VERSION %mltable);
  
  $VERSION = 99.1117;
  
  CONFIG:	{
  	%mltable = qw(
  		 1	31
  		 3	31
  		 4	30
  		 5	31
  		 6	30
  		 7	31
  		 8	31
  		 9	30
  		10	31
  		11	30
  		12	31);
  }
  
  sub days_in
  {
  	# Month is 1..12
  	my ($year, $month) = @_;
  	return $mltable{$month+0} unless $month == 2;
  	return 28 unless &is_leap($year);
  	return 29;
  }
  
  sub is_leap
  {
  	my ($year) = @_;
  	return 0 unless $year % 4 == 0;
  	return 1 unless $year % 100 == 0;
  	return 0 unless $year % 400 == 0;
  	return 1;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::DaysInMonth -- simply report the number of days in a month
  
  =head1 SYNOPSIS
  
  	use Time::DaysInMonth;
  	$days = days_in($year, $month_1_to_12);
  	$leapyear = is_leap($year);
  
  =head1 DESCRIPTION
  
  DaysInMonth is simply a package to report the number of days in
  a month.  That's all it does.  Really!
  
  =head1 AUTHOR
  
  David Muir Sharnoff <muir@idiom.org>
  
  =head1 BUGS
  
  This only deals with the "modern" calendar.  Look elsewhere for 
  historical time and date support.
  
  =head1 LICENSE
  
  Copyright (C) 1996-1999 David Muir Sharnoff.  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to muir@idiom.org.
  
TIME_DAYSINMONTH

$fatpacked{"Time/Fields.pm"} = <<'TIME_FIELDS';
  # 382C8tQ - Time::Fields.pm created by Pip@CPAN.Org as an abstract base 
  #   class for more specialized Time objects (Time::Frame && Time::PT).
  # Notz: 
  #   timelocal($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
  #   Unix epoch 1970-2036 or something
  #   PT   epoch 1361-2631
  #   potential smaller fields:
  #       kink as 60th-of-a-jink? tink as 60th-of-a-kink? ... X as 60th-of-a-Y
  #     frame 0.0166666666666667        CYMDhmsfjktbpaz
  #     jink  0.000277777777777778               0.3 milliseconds (thousanths)
  #     kink  0.00000462962962962963             5   microseconds (millionths)
  #     tink  0.0000000771604938271605          77   nano seconds (billionths)
  #     blip  0.00000000128600823045267          1   nano second 
  #       RealTimeOperatingSystems may need micro or nano second precision
  #     pip   0.0000000000214334705075446       21   pico seconds (trillionths)
  #     ax    0.000000000000357224508459076      0.4 pico seconds
  #           0.00000000000000595374180765127    6   femtoseconds (10e-15)
  #           0.0000000000000000992290301275212 99   atto seconds (10e-18)
  #           0.00000000000000000165381716879202 2   atto seconds
  #           0.000000000000000000027563619479867            27   zepto   -21
  #           0.000000000000000000000459393657997783          0.5 zepto
  #           0.00000000000000000000000765656096662972        8   yocto   -24
  #           0.000000000000000000000000127609349443829       0.1 yocto
  #           0.00000000000000000000000000212682249073048     2   harpo   -27
  #           0.0000000000000000000000000000354470415121746  35   groucho -30
  #           0.000000000000000000000000000000590784025202911 0.6 groucho
  #      zepto (10e-21) yocto (10e-24) harpo (10e-27) groucho (10e-30) 
  #      zeppo (10e-33) gummo (10e-36) chico (10e-39)
  
  =head1 NAME
  
  Time::Fields - abstract objects to store distinct time fields
  
  =head1 VERSION
  
  This documentation refers to version 1.2.565EHOV of 
  Time::Fields, which was released on Sun Jun  5 14:17:24:31 2005.
  
  =head1 SYNOPSIS
  
    package Time::Fields::NewChildPackageOfTimeFields;
    use base qw(Time::Fields);
  
    # NewChildPackageOfTimeFields definition...
  
  =head1 DESCRIPTION
  
  Time::Fields defines simple time objects with distinct fields for:
  
    Century, Year, Month, Day, hour, minute, second, frame, jink, zone
  
  along with methods to manipulate those fields && modify their
  default presentation.  Normally, a frame is one 60th-of-a-
  second && a jink is one 60th-of-a-frame or about 0.3 milliseconds.
  The plural for 'jink' is 'jinx'.  Fields data && methods are 
  meant to be inherited by other classes (namely L<Time::Frame> && 
  L<Time::PT>) which implement specific useful interpretations of 
  individual Time::Fields.
  
  =head1 2DO
  
  =over 2
  
  =item - use_? filters should get auto-set when unused fields get assigned
  
  =item -     What else does Fields need?
  
  =back
  
  =head1 WHY?
  
  The reason I created Fields was that I have grown so enamored with
  Base64 representations of everything around me that I was 
  compelled to write a simple clock utility ( `pt` ) using Base64.
  This demonstrated the benefit to be gained from time objects with
  distinct fields && configurable precision.  Thus, Time::Fields
  was written to be the abstract base class for:
  
    Time::Frame  ( creates objects which represent spans    of time )
        && 
    Time::PT     ( creates objects which represent instants in time )
  
  =head1 USAGE
  
  Many of Time::Fields's methods have been patterned after the 
  excellent L<Time::Piece> module written by Matt Sergeant 
  <matt@sergeant.org> && Jarkko Hietaniemi <jhi@iki.fi>.
  
  =head2 new(<InitType>, <InitData>)
  
  Time::Fields's constructor can be 
  called as a class method to create a brand new object or as
  an object method to copy an existing object.  Beyond that,
  new() can initialize Fields objects the following ways:
  
    * <packedB64InitStringImplies'str'>
      eg. Time::Fields->new('0123456789');
    * 'str'  => <packedB64InitString>
      eg. Time::Fields->new('str'  => '0123456789');
    * 'list' => <arrayRef>
      eg. Time::Fields->new('list' => [0, 1, 2..9]);
    * 'hash' => <hashRef>
      eg. Time::Fields->new('hash' => {'jink' => 8, 'year' => 2003})
  
  b<*Note*>  If only a valid 'str'-type parameter is given to new 
  (but no accompanying initialization value), the parameter 
  is interpreted as an implied 'str' value.
  
      eg. Time::Fields->new('0123456789');
  
  This implied 'str'-type initialization will probably be
  the most common Time::Fields object creation mechanism
  when individual fields do not exceed 64 since this 
  efficient representation is why the module was created.
  
  The following methods allow access to individual fields of 
  existent Time::Fields objects:
  
    $t->C  or  $t->century
    $t->Y  or  $t->year
    $t->M  or  $t->month
    $t->D  or  $t->day
    $t->h  or  $t->hour
    $t->m  or  $t->minute
    $t->s  or  $t->second
    $t->f  or  $t->frame
    $t->j  or  $t->jink
    $t->z  or  $t->zone
  
  Any combination of above single letters can be used as well.  
  Following are some common useful examples:
  
    $t->hms                 # returns list of fields eg. [12, 34, 56]
    $t->hms(12, 56, 34)     # sets fields: h = 12, m = 56, s = 34
    $t->hmsf                # [12, 34, 56, 12]
    $t->hmsfj               # [12, 34, 56, 12, 34]
    $t->hmsfjz              # [12, 34, 56, 12, 34, 16]
    $t->time                # same as $t->hms
    $t->alltime             # same as $t->hmsfjz
    $t->YMD                 # [2000,  2,   29]
    $t->MDY                 # [   2, 29, 2000]
    $t->DMY                 # [  29,  2, 2000]
    $t->CYMD                # [  20,  0,    2, 29]
    $t->date                # same as $t->YMD
    $t->alldate             # same as $t->CYMD
    $t->CYMDhmsfjz          # [  20,  0,    2, 29, 12, 13, 56, 12, 13, 16]
    $t->dt                  # same as $t->CYMDhmsfjz
    $t->all                 # same as $t->CYMDhmsfjz
    "$t"                    # same as $t->CYMDhmsfjz
  
  =head2 Month / minute Exceptions
  
  Fields object method names can be in any case with the following
  exceptions.  Special handling exists to resolve ambiguity between
  the Month && minute fields.  If a lowercase 'm' is used adjacent to
  a 'y' or 'd' of either case, it is interpreted as Month.  Otherwise,
  the case of the 'm' distinguishes Month from minute.  An uppercase
  'M' is ALWAYS Month.  An adjacent uppercase 'H' or 'S' will not turn
  an uppercase 'M' into minute.  Method names which need to specify
  Month or minute fields can also optionally be uniquely specified by
  their distinguishing vowel ('o' or 'i') instead of 'M' or 'm'.
  
    $t->ymd                 # same as $t->YMD
    $t->dmy                 # same as $t->DMY
    $t->MmMm                # Month minute Month minute
    $t->HMS                 # hour Month second! NOT same as $t->hms 
    $t->yod                 # same as $t->YMD
    $t->chmod               # Century hour minute Month Day
    $t->FooIsMyJoy          # frame Month Month     minute second
                            #      Month Year     jink Month Year
  
  =head1 NOTES
  
  Whenever individual Time::Fields attributes are going to be 
  printed or an entire object can be printed with multi-colors,
  the following mapping should be employed whenever possible:
  
             D      Century -> DarkRed
             A      Year    -> Red
             T      Month   -> Orange
             E      Day     -> Yellow
                     hour   -> Green
              t      minute -> Cyan
              i      second -> Blue
              m      frame  -> Purple
              e      jink   -> DarkPurple
                     zone   -> Grey or White
  
  Even though Time::Fields is designed to be an abstract base class,
  it has not been written to croak on direct usage && object 
  instantiation because simple Fields objects may already be
  worthwhile.
  
  I hope you find Time::Fields useful.  Please feel free to e-mail
  me any suggestions || coding tips || notes of appreciation 
  ("app-ree-see-ay-shun").  Thank you.  TTFN.
  
  =head1 CHANGES
  
  Revision history for Perl extension Time::Fields:
  
  =over 4
  
  =item - 1.2.565EHOV  Sun Jun  5 14:17:24:31 2005
  
  * combined Fields, Frame, && PT into one pkg (so see PT CHANGES section
      for updates to Fields or Frame)
  
  =item - 1.0.3CCA4Eh  Fri Dec 12 10:04:14:43 2003
  
  * removed indenting from POD NAME field
  
  =item - 1.0.3CB7Qb0  Thu Dec 11 07:26:37:00 2003
  
  * updated pod && prepared for release
  
  =item - 1.0.3CA8oiI  Wed Dec 10 08:50:44:18 2003
  
  * cleaned up documentation
  
  * implemented use methods
  
  * overloaded for stringification
  
  =item - 1.0.39GHeCl  Tue Sep 16 17:40:12:47 2003
  
  * incorporated stuff learned from ObjectOrientedPerl (Conway)
  
  =item - 1.0.382DLbX  Sat Aug  2 13:21:37:33 2003
  
  * fleshed out documentation && ideas
  
  =item - 1.0.37VG26k  Thu Jul 31 16:02:06:46 2003
  
  * original version
  
  =back
  
  =head1 INSTALL
  
  Please run:
  
      `perl -MCPAN -e "install Time::PT"`
  
  or uncompress the package && run the standard:
  
      `perl Makefile.PL; make; make test; make install`
  
  =head1 FILES
  
  Time::Fields requires:
  
  L<Carp>                to allow errors to croak() from calling sub
  
  L<Math::BaseCnv>       to handle number-base conversion
  
  Time::Fields utilizes (if available):
  
  L<Time::HiRes>         to provide sub-second time precision
  
  L<Time::Local>         to provide Unix time conversion options
  
  =head1 SEE ALSO
  
  Time::Frame && Time::PT
  
  =head1 LICENSE
  
  Most source code should be Free!
    Code I have lawful authority over is && shall be!
  Copyright: (c) 2003-2004, Pip Stuart.
  Copyleft : This software is licensed under the GNU General Public
    License (version 2), && as such comes with NO WARRANTY.  Please
    consult the Free Software Foundation (http://FSF.Org) for
    important information about your freedom.
  
  =head1 AUTHOR
  
  Pip Stuart <Pip@CPAN.Org>
  
  =cut
  
  package Time::Fields;
  use strict;
  use vars qw( $AUTOLOAD );
  our $VERSION     = '1.2.565EHOV'; # major . minor . PipTimeStamp
  our $PTVR        = $VERSION; $PTVR =~ s/^\d+\.\d+\.//; # strip major && minor
  # Please see `perldoc Time::PT` for an explanation of $PTVR.
  use overload 
    q("") => sub { # anonymous stringify()
               my @fdat = $_[0]->CYMDhmsfjz(); 
               my @attz = $_[0]->_attribute_names();
               my $tstr = '';
               for(my $i=0; $i<@fdat; $i++) {
                 $attz[$i] =~ s/^_(.).*/$1/;
                 $attz[$i] = uc($attz[$i]) if($i < 4);
                 $fdat[$i] = 0 unless(defined($fdat[$i]));
                 $tstr .= $attz[$i] . ':' . $fdat[$i];
                 $tstr .= ', ' if($i < $#fdat);
               }
               return($tstr);
             };
  
  use Carp;
  use Math::BaseCnv qw(:all);
  my $locl = eval("use Time::Local; 1") || 0;
  my $hirs = eval("use Time::HiRes; 1") || 0;
  #my $simp = eval("use Curses::Simp; 1") || 0; # ADD to FILES POD if use Simp!
  
  # ordered attribute names array, match string for regular expressions, &&
  #                                default attribute data hash
  my @_attrnamz = ();             my %_attrmtch = ();
                                  my %_attrdata = ();
  # field data
  push(@_attrnamz, '_century');      $_attrmtch{$_attrnamz[-1]} = 'C';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_year');         $_attrmtch{$_attrnamz[-1]} = 'Y';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_month');        $_attrmtch{$_attrnamz[-1]} = 'O';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_day');          $_attrmtch{$_attrnamz[-1]} = 'D';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_hour');         $_attrmtch{$_attrnamz[-1]} = 'h';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_minute');       $_attrmtch{$_attrnamz[-1]} = 'i';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_second');       $_attrmtch{$_attrnamz[-1]} = 's';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_frame');        $_attrmtch{$_attrnamz[-1]} = 'f';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_jink');         $_attrmtch{$_attrnamz[-1]} = 'j';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  push(@_attrnamz, '_zone');         $_attrmtch{$_attrnamz[-1]} = 'z';
                                     $_attrdata{$_attrnamz[-1]} =     0;
  # ratios of frames-per-second && jinx-per-frame
  push(@_attrnamz, '__fps');         $_attrdata{$_attrnamz[-1]} = 60;
  push(@_attrnamz, '__jpf');         $_attrdata{$_attrnamz[-1]} = 60;
  # filter flags for which particular fields should be used by default
  push(@_attrnamz, '__use_century'); $_attrdata{$_attrnamz[-1]} = 0;
  push(@_attrnamz, '__use_year');    $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_month');   $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_day');     $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_hour');    $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_minute');  $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_second');  $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_frame');   $_attrdata{$_attrnamz[-1]} = 1;
  push(@_attrnamz, '__use_jink');    $_attrdata{$_attrnamz[-1]} = 0;
  push(@_attrnamz, '__use_zone');    $_attrdata{$_attrnamz[-1]} = 0;
  # global field color codes in a hash of arrays
  my %_fielclrz = (
       'simp' => ['!r',    # DarkRed    Century
                  '!R',    # Red        Year
                  '!O',    # Orange     Month
                  '!Y',    # Yellow     Day
                  '!G',    # Green       hour
                  '!C',    # Cyan        minute
                  '!U',    # Blue        second
                  '!P',    # Purple      frame
                  '!p',    # DarkPurple  jink
                  '!w'],   # Grey        zone
       'html' => ['7F0B1B',  # DarkRed    Century
                  'FF1B2B',  # Red        Year
                  'FF7B2B',  # Orange     Month
                  'FFFF1B',  # Yellow     Day
                  '1BFF3B',  # Green       hour
                  '1BFFFF',  # Cyan        minute
                  '1B7BFF',  # Blue        second
                  'BB1BFF',  # Purple      frame
                  '5B0B7F',  # DarkPurple  jink
                  '7F7F7F'], # Grey        zone
       'ansi' => ["\e[0;31m",  # DarkRed    Century
                  "\e[1;31m",  # Red        Year
                  "\e[0;33m",  # Orange     Month
                  "\e[1;33m",  # Yellow     Day
                  "\e[1;32m",  # Green       hour
                  "\e[1;36m",  # Cyan        minute
                  "\e[1;34m",  # Blue        second
                  "\e[1;35m",  # Purple      frame
                  "\e[0;35m",  # DarkPurple  jink
                  "\e[0;30m"], # Grey        zone
       '4nt'  => ["04",      # DarkRed    Century
                  "0c",      # Red        Year
                  "06",      # Orange     Month
                  "0e",      # Yellow     Day
                  "0a",      # Green       hour
                  "0b",      # Cyan        minute
                  "09",      # Blue        second
                  "0d",      # Purple      frame
                  "05",      # DarkPurple  jink
                  "07"],     # Grey        zone
  ); 
  
  # methods
  sub _default_value   { my ($self, $attr) = @_; $_attrdata{$attr}; } # Dflt vals
  sub _attribute_match { my ($self, $attr) = @_; $_attrmtch{$attr}; } # matching
  sub _attribute_names { @_attrnamz; } # attribute names
  sub _Time_Local  { $locl; } # can Time::Local be used?
  sub _Time_HiRes  { $hirs; } # can Time::HiRes be used?
  #sub _Curses_Simp { $simp; } # can Curses::Simp be used?
  
  # Time::Fields object constructor as class method or copy as object method.
  # First param can be ref to copy.  Not including optional ref from 
  #   copy, default is no params to create a new empty Fields object.
  # If params are supplied, they must be a single key && a single value.
  # The key must be one of the following 3 types of constructor 
  #   initialization mechanisms:
  #     0) 'str'  => <packedB64InitString>  (eg. 'str'  => '0123456789')
  #     1) 'list' => <arrayRef>             (eg. 'list' => [0, 1, 2..9])
  #     2) 'hash' => <hashRef>              (eg. 'hash' => {'jink' => 8})
  sub new { 
    my ($nvkr, $ityp, $idat) = @_; 
    my $nobj = ref($nvkr);
    my $clas = $ityp;
    $clas = $nobj || $nvkr if(!defined($ityp) || $ityp !~ /::/);
    my $self = bless({}, $clas);
    foreach my $attr ( $self->_attribute_names() ) { 
      $self->{$attr} = $self->_default_value($attr); # init defaults
      $self->{$attr} = $nvkr->{$attr} if($nobj);     #  && copy if supposed to
    }
    # there were init params with no colon (classname)
    if(defined($ityp) && $ityp !~ /::/) { 
      ($ityp, $idat) = ('str', $ityp) unless(defined($idat));
      foreach my $attr ( $self->_attribute_names() ) {
        if     ($ityp =~ /^s/i) {    # 'str'
          $self->{$attr} = b10($1) if($idat =~ s/^(.)//);  # break down string
        } elsif($ityp =~ /^[la]/i) { # 'list' or 'array'
          $self->{$attr} = shift( @{$idat} ) if(@{$idat}); # shift list vals
        } elsif($ityp =~ /^h/i) {    # 'hash'
          # do some searching to find hash key that matches
          foreach(keys(%{$idat})) {
            if($attr =~ /$_/) {
              $self->{$attr} = $idat->{$_};
              delete($idat->{$_});
            }
          }
        } else { # undetected init type
          croak "!*EROR*! Time::Fields::new initialization type: $ityp did not match 'str', 'list', or 'hash'!\n";
        }
      }
    }
    return($self);
  }
  
  sub _field_colors { # return the color code array associated with a type
    my $self = shift; my $type = shift;
    $type = 'ansi' unless(defined($type) && exists($_fielclrz{lc($type)}));
    return($_fielclrz{ lc($type) });
  }
  
  sub _color_fields { # return a color string for a Fields object
    my $self = shift;
    my $fstr = shift || ' ' x 10; $fstr =~ s/0+$// if(length($fstr) <= 7);
    my $ctyp = shift || 'ansi';
    my @clrz = (); my $coun = 0; my $rstr = '';
    if     ($ctyp =~ /^s/i) { # simp color codes
      @clrz = @{$self->_field_colors('simp')};
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun++]; }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun++)]; }
      }
    } elsif($ctyp =~ /^h/i) { # HTML link && font color tag delimiters
      @clrz = @{$self->_field_colors('html')};
      $_    = '<font color="#' . $_ . '">' foreach(@clrz);
      $rstr = '<a href="http://Ax9.Org/pt?' . $fstr . '">';
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1) . '</font>'; }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun)] . substr($fstr, $coun++, 1) . '</font>'; }
      }
      $rstr .= '</a>';
    } else { # ANSI escapes
      @clrz = @{$self->_field_colors('ansi')};
      if($ctyp =~ /^z/i) { # zsh prompt needs delimited %{ ANSI %}
        for(my $i=0; $i<@clrz; $i++) { $clrz[$i] = '%{' . $clrz[$i] . '%}'; }
      }
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1); }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun)] . substr($fstr, $coun++, 1); }
      }
    }
    return($rstr);
  }
  
  sub color { # generic self color method to call overloaded subclass colorfields
    my $self = shift; 
    my $fstr = "$self"; 
    my $ctyp = shift || 'ansi';
    return($self->_color_fields($fstr, $ctyp));
  }
  
  sub AUTOLOAD { # methods (created as necessary)
    no strict 'refs';
    my ($self, $nwvl) = @_;
  
    # normal set_/get_ methods
    if     ($AUTOLOAD =~ /.*::[sg]et(_\w+)/i) {
      my $atnm = lc($1);
      *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
      $self->{$atnm} = $nwvl if(@_ > 1);
      return($self->{$atnm});
    # use_??? to set/get field filters
    } elsif($AUTOLOAD =~ /.*::(use_\w+)/i) {
      my $atnm = '__' . lc($1);
      *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
      $self->{$atnm} = $nwvl if(@_ > 1);
      return($self->{$atnm});
    # Alias methods which must be detected before sweeps
    } elsif($AUTOLOAD =~ /.*::time$/i) { 
      *{$AUTOLOAD} = sub { return($self->hms()); };
      return($self->hms());
    } elsif($AUTOLOAD =~ /.*::alltime$/i) { 
      *{$AUTOLOAD} = sub { return($self->hmsfjz()); };
      return($self->hmsfjz());
    } elsif($AUTOLOAD =~ /.*::date$/i) { 
      *{$AUTOLOAD} = sub { return($self->YMD()); };
      return($self->YMD());
    } elsif($AUTOLOAD =~ /.*::alldate$/i) { 
      *{$AUTOLOAD} = sub { return($self->CYMD()); };
      return($self->CYMD());
    } elsif($AUTOLOAD =~ /.*::all$/i) { 
      *{$AUTOLOAD} = sub { return($self->CYMDhmsfjz()); };
      return($self->CYMDhmsfjz());
    } elsif($AUTOLOAD =~ /.*::dt$/i) { 
      *{$AUTOLOAD} = sub { return($self->CYMDhmsfjz()); };
      return($self->CYMDhmsfjz());
    } elsif($AUTOLOAD =~ /.*::mday$/i) { my $atnm = '_day';
      *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
      $self->{$atnm} = $nwvl if(@_ > 1); return($self->{$atnm});
    # all joint field methods (eg. YMD(), hms(), foo(), etc.
    } elsif($AUTOLOAD =~ /.*::([CYMODhmisfjz][CYMODhmisfjz]+)$/i) { 
      my @fldl = split(//, $1); 
      my ($self, @nval) = @_; my @rval = (); my $atnm = ''; my $rgex;
      # handle Month / minute exceptions
      for(my $i=0; $i<$#fldl; $i++) {
        $fldl[$i + 1] = 'O' if($fldl[$i] =~ /[yd]/i && $fldl[$i + 1] eq 'm');
        $fldl[$i    ] = 'O' if($fldl[$i] eq 'm'     && $fldl[$i + 1] =~ /[yd]/i);
        $fldl[$i    ] = 'O' if($fldl[$i] eq 'M');
        $fldl[$i    ] = 'i' if($fldl[$i] eq 'm');
      }
      *{$AUTOLOAD} = sub { 
        my ($self, @nval) = @_; my @rval = (); 
        for(my $i=0; $i<@fldl; $i++) {
          foreach my $attr ($self->_attribute_names()){
            my $mtch = $self->_attribute_match($attr);
            if(defined($mtch) && $fldl[$i] =~ /^$mtch/i) {
              $self->{$attr} = $nval[$i] if($i < @nval);
              push(@rval, $self->{$attr});
            }
          }
        }
        return(@rval);
      };
      for(my $i=0; $i<@fldl; $i++) {
        foreach my $attr ($self->_attribute_names()){
          my $mtch = $self->_attribute_match($attr);
          if(defined($mtch) && $fldl[$i] =~ /$mtch/i) {
            $self->{$attr} = $nval[$i] if($i < @nval);
            push(@rval, $self->{$attr});
          }
        }
      }
      return(@rval);
    # sweeping matches to handle partial keys
    } elsif($AUTOLOAD =~ /.*::[-_]?([CYMODhmisfjz])(.)?/i) { 
      my ($atl1, $atl2) = ($1, $2); my $atnm;
      $atl1 = 'O' if($atl1 eq 'm' && defined($atl2) && lc($atl2) eq 'o');
      $atl1 = 'i' if($atl1 eq 'M' && defined($atl2) && lc($atl2) eq 'i');
      $atl1 = 'O' if($atl1 eq 'M');
      $atl1 = 'i' if($atl1 eq 'm');
      foreach my $attr ($self->_attribute_names()){
        my $mtch = $self->_attribute_match($attr);
        $atnm = $attr if(defined($mtch) && $atl1 =~ /$mtch/i);
      }
      if($atl1 eq 'O') {
        if($AUTOLOAD =~ /.*::_/) { # 0-based month
          *{$AUTOLOAD} = sub { $_[0]->{$atnm} = ($_[1] + 1) if(@_ > 1); return($_[0]->{$atnm} - 1); };
          $self->{$atnm} = ($nwvl + 1) if(@_ > 1);
          return($self->{$atnm} - 1);
        }
      }
      *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
      $self->{$atnm} = $nwvl if(@_ > 1);
      return($self->{$atnm});
    } else {
      croak "No such method: $AUTOLOAD\n";
    }
  }
  
  sub DESTROY { } # do nothing but define in case && to calm warning in test.pl
  
  127;
TIME_FIELDS

$fatpacked{"Time/Frame.pm"} = <<'TIME_FRAME';
  # 37VG26k - Time::Frame.pm created by Pip@CPAN.Org to make simple
  #   objects for frames of time.
  # Desc: Frame describes a simple object which encapsulates 10 fields:
  #     Century, Year, Month, Day, hour, minute, second, frame, jink, zone
  #   where frame is normally 1/60th-of-a-second && jink is normally 
  #   1/60th-of-a-frame.  The objects describe a high-precision time-frame 
  #   (as in, a duration, a period, a length or span of time).  Frame 
  #   objects can be added to / subtracted from Time::PT objects to yield 
  #   new specific PT instants.
  #     1st: '0A1B2C3'
  #     2nd: 'Yd:2003,j:A7_,M:a3I' or 'f:3aL9.eP' 
  #     if field name ends with d, value is read as decimal nstd of default b64.
  #     Third way is super verbose decimal strings:
  #       '15 years, 3 months, 7 weeks, 4 jinx' can use any (or none) sep but :
  #     4th is hash
  #     Total Jinx possible for PT: 1,680,238,080,000,000 (1.7 quatrillion)
  #           JnxPTEpoch -> `pt __nWO0000` -> Midnight Jan. 1 7039 BCE
  #              PTEpoch -> `pt  _nWO`     -> Midnight Jan. 1 1361  CE
  #   Frame members:
  #     new inits either with pt-param, expanded, or empty
  #
  #     settle fields (like return new Frame object with only total secs of old)
  #     re-def frame as other than 60th-of-a-second
  #     re-def jink  as other than 60th-of-a-frame
  #       eg. def f && j limits as 31.6227766016838 (sqrt(1000)) for ms jinx
  #           or just def f as 1000 for exactly ms frames
  #     allow month/year modes to be set to avg or relative
  #
  #  My Base64 encoding uses characters: 0-9 A-Z a-z . _  since I don't like
  #    having spaces or plusses in my time strings.  I need times to be easy to
  #    append to filenames for very precise, consice, time-stamp versioning.
  #  Each encoded character represents (normally) just a single date or time 
  #    field.  All fields are 0-based except Month && Day.  The fields are:
  #      Year-2000, Month, Day, Hour, Minute, Second, Frame (60th-of-a-second)
  #  There are three (3) exceptions to the rule that each character only
  #    represents one date or time field.  The bits are there so... why not? =)
  #  0) Each 12 added to the Month adds  64 to the Year.
  #  1)      24 added to the Hour  adds 320 to the Year.
  #  2)      31 added to the Day   makes the year negative just before adding 
  #            2000.
  
  =head1 NAME
  
  Time::Frame - objects to store a length of time
  
  =head1 VERSION
  
  This documentation refers to version 1.2.565EHOV of 
  Time::Frame, which was released on Sun Jun  5 14:17:24:31 2005.
  
  =head1 SYNOPSIS
  
    use Time::Frame;
    
    my $f = Time::Frame->new('verbose' => '2 weeks');
    print 'Number of days is ', $f->day(), "\n";
  
  =head1 DESCRIPTION
  
  This module has been adapted from the Time::Seconds module 
  written by Matt Sergeant <matt@sergeant.org> && Jarkko 
  Hietaniemi <jhi@iki.fi>.  Time::Frame inherits base 
  data structure && object methods from Time::Fields.  
  Frame was written to simplify storage && calculation 
  of encoded, yet distinct && human-readable, time data 
  objects.
  
  The title of this Perl module has dual meaning.  Frame
  means both the span of time the whole object represents
  as well as the (default) smallest unit of measurement.
  
  =head1 2DO
  
  =over 2
  
  =item - copy total_frames into AUTOLOAD for (in|as|total)_(CYMDhmsfj)
            functions which convert to any field
  
  =item - better ways to specify common verbose sizes
  
  =item -     What else does Frame need?
  
  =back
  
  =head1 WHY?
  
  The reason I created Frame was that I have grown so enamored with
  Base64 representations of everything around me that I was 
  compelled to write a simple clock utility ( `pt` ) using Base64.
  This demonstrated the benefit to be gained from time objects with
  distinct fields && configurable precision.  Thus, L<Time::Fields>
  was written to be the abstract base class for:
  
      Time::Frame  ( creates objects which represent spans    of time )
          && 
      Time::PT     ( creates objects which represent instants in time )
  
  =head1 USAGE
  
  Many of Time::Frame's methods have been patterned after the excellent
  L<Time::Piece> module written by Matt Sergeant <matt@sergeant.org>
  && Jarkko Hietaniemi <jhi@iki.fi>.
  
  =head2 new(<InitType>, <InitData>)
  
  Time::Frame's constructor can be called as a class method to create a
  brand new object or as an object method to copy an existing object.
  Beyond that, new() can initialize Frame objects in the following ways:
  
    * <packedB64InitStringImplies'str'>
      eg. Time::Frame->new('0123456789');
    * 'str'  => <packedB64InitString>
      eg. Time::Frame->new('str'  => '0A1B2C3D4E');
    * 'list' => <arrayRef>
      eg. Time::Frame->new('list' => [0, 1, 2..9]);
    * 'hash' => <hashRef>
      eg. Time::Frame->new('hash' => {'jink' => 8, 'year' => 2003})
  
  =head2 total_frames()
  
  total_frames simply returns the total number of frames a Time::Frame
  object specifies.
  
  =head2 color(<DestinationColorTypeFormat>)
  
  This is an object member
  which will join Base64 representations of each field that has
  been specified in use() && joins them with color-codes or color
  escape sequences with formats for varied uses.  Currently
  available DestinationColorTypeFormats are:
  
      'ANSI'  # eg. \e[1;32m
      'zsh'   # eg. %{\e[1;33m%}
      'HTML'  # eg. <a href="http://Ax9.Org/pt?"><font color="#FF1B2B">
      'Simp'  # eg. RbobYbGbCbUbPb
  
  The following methods allow access to individual fields of 
  Time::Frame objects:
  
    $t->C  or  $t->century
    $t->Y  or  $t->year
    $t->M  or  $t->month
    $t->D  or  $t->day
    $t->h  or  $t->hour
    $t->m  or  $t->minute
    $t->s  or  $t->second
    $t->f  or  $t->frame
    $t->j  or  $t->jink
    $t->z  or  $t->zone
  
  Please see L<Time::Fields> for a more thorough description of field
  accessor methods.
  
  =head1 NOTES
  
  Whenever individual Time::Frame attributes are going to be 
  printed or an entire object can be printed with multi-colors,
  the following mapping should be employed whenever possible:
  
            D       Century -> DarkRed
            A       Year    -> Red
            T       Month   -> Orange
            E       Day     -> Yellow
                     hour   -> Green
             t       minute -> Cyan
             i       second -> Blue
             m       frame  -> Purple
             e       jink   -> DarkPurple
                     zone   -> Grey or White
  
  Please see the color() member function in the USAGE section.
  
  I hope you find Time::Frame useful.  Please feel free to e-mail
  me any suggestions || coding tips || notes of appreciation 
  ("app-ree-see-ay-shun").  Thank you.  TTFN.
  
  =head1 CHANGES
  
  Revision history for Perl extension Time::Frame:
  
  =over 4
  
  =item - 1.2.565EHOV  Sun Jun  5 14:17:24:31 2005
  
  * combined Fields, Frame, && PT into one pkg (so see PT CHANGES section
      for updates to Fields or Frame)
  
  =item - 1.0.3CCA3bG  Fri Dec 12 10:03:37:16 2003
  
  * removed indenting from POD NAME field
  
  =item - 1.0.3CB7RLu  Thu Dec 11 07:27:21:56 2003
  
  * added HTML color option && prepared for release
  
  =item - 1.0.3CA8thM  Wed Dec 10 08:55:43:22 2003
  
  * built class to inherit from Time::Fields
  
  =item - 1.0.37VG26k  Thu Jul 31 16:02:06:46 2003
  
  * original version
  
  =back
  
  =head1 INSTALL
  
  Please run:
  
        `perl -MCPAN -e "install Time::PT"`
  
  or uncompress the package && run the standard:
  
        `perl Makefile.PL; make; make test; make install`
  
  =head1 FILES
  
  Time::Frame requires:
  
  L<Carp>                to allow errors to croak() from calling sub
  
  L<Math::BaseCnv>       to handle number-base conversion
  
  L<Time::Fields>        to provide underlying object structure
  
  =head1 SEE ALSO
  
  L<Time::PT>
  
  =head1 LICENSE
  
  Most source code should be Free!
    Code I have lawful authority over is && shall be!
  Copyright: (c) 2003-2004, Pip Stuart.
  Copyleft : This software is licensed under the GNU General Public
    License (version 2), && as such comes with NO WARRANTY.  Please
    consult the Free Software Foundation (http://FSF.Org) for
    important information about your freedom.
  
  =head1 AUTHOR
  
  Pip Stuart <Pip@CPAN.Org>
  
  =cut
  
  package Time::Frame;
  use strict;
  require      Time::Fields;
  use base qw( Time::Fields );
  use vars qw( $AUTOLOAD );
  use Carp;
  use Math::BaseCnv qw( :all );
  our $VERSION     = '1.2.565EHOV'; # major . minor . PipTimeStamp
  our $PTVR        = $VERSION; $PTVR =~ s/^\d+\.\d+\.//; # strip major && minor
  # Please see `perldoc Time::PT` for an explanation of $PTVR.
  use constant ONE_MINUTE          => '1 min';                  #         60;
  use constant ONE_HOUR            => '1 hour';                 #      3_600;
  use constant ONE_DAY             => '1 day';                  #     86_400;
  use constant ONE_WEEK            => '1 week';                 #    604_800;
  use constant ONE_REAL_MONTH      => '1 month';                #        '1M';
  use constant ONE_REAL_YEAR       => '1 year';                 #        '1Y';
  use constant ONE_MONTH           => '1 average month';        #  2_629_744;
                                                                 # ONE_YEAR / 12
  use constant ONE_FINANCIAL_MONTH => '1 financial month';      #  2_592_000;
                                                                 # 30 days
  use constant ONE_YEAR            => '1 average year';         # 31_556_930;
                                                                 # 365.24225 days
  use constant LEAP_YEAR           => '1 leap year';            # 31_622_400;
                                                                 # 366 * ONE_DAY
  use constant NON_LEAP_YEAR       => '1 nonleap year';         # 31_536_000;
                                                                 # 365 * ONE_DAY
  
  use overload 
    q("")  => \&_stringify,
    q(<=>) => \&_cmp_num,
    q(cmp) => \&_cmp_str,
    q(+)   => \&_add,
    q(-)   => \&_sub;
  
  sub _stringify { # cat non-zero b64 fields down to frame or should just be used fields
    my @fdat = $_[0]->CYMDhmsfjz(); 
    my @attz = $_[0]->_attribute_names();
    my $tstr = ''; my $toob = 0; # flag designating field too big
    foreach(@fdat) {
      $toob = 1 if($_ > 63);
    }
    if($toob) {
      for(my $i=0; $i<@fdat; $i++) {
        $attz[$i] =~ s/^_(.).*/$1/;
        $attz[$i] = uc($attz[$i]) if($i < 4 || $i == $#fdat);
        $tstr .= $attz[$i] . ':' . $fdat[$i];
        $tstr .= ', ' if($i < $#fdat);
      }
    } else {
      for(my $i=0; $i<@fdat; $i++) {
        if($fdat[$i]) {
          $tstr .= b64($fdat[$i]);
          while($i < 7) { $tstr .= b64($fdat[++$i]); }
        }
      }
    }
    return($tstr);
  }
  
  sub _cmp_num {
    my ($larg, $rarg, $srvr) = @_;
    ($larg, $rarg) = ($rarg, Time::Frame->new($larg)) if($srvr); # mk both args Frame objects
    # maybe compare _total_jinx() or something
    return(0);
  }
  
  sub _cmp_str { 
    my $r = _cmp_num(@_); 
    ($r < 0) ? return('lt') : ($r) ? return('gt') : return('eq');
  }
  
  # Frame + Frame = Frame
  # Frame + PT    = PT      (calculation is passed off to PT.pm)
  # Frame + 'str' = PT      (passed off to PT.pm after PT->new('str') is made)
  # Frame + anything else is not supported yet
  sub _add {
    my ($larg, $rarg, $srvr) = @_; my $rslt;
    $larg = Time::PT->new($larg) if($srvr);
    $rarg = Time::PT->new($rarg) unless(ref($rarg) && $rarg->isa('Time::Frame'));
    if((ref($larg) && $larg->isa('Time::PT')) ||
       (ref($rarg) && $rarg->isa('Time::PT'))) {
      $rslt = $larg + $rarg; # pass off calculation to PT.pm
    } else {
      $rslt = Time::Frame->new();
      $rslt->{'_zone'}    = $larg->z + $rarg->z;
      $rslt->{'_jink'}    = $larg->j + $rarg->j;
      $rslt->{'_frame'}   = $larg->f + $rarg->f;
      $rslt->{'_second'}  = $larg->s + $rarg->s;
      $rslt->{'_minute'}  = $larg->i + $rarg->i;
      $rslt->{'_hour'}    = $larg->h + $rarg->h;
      $rslt->{'_day'}     = $larg->D + $rarg->D;
      $rslt->{'_month'}   = $larg->O + $rarg->O;
      $rslt->{'_year'}    = $larg->Y + $rarg->Y;
      $rslt->{'_century'} = $larg->C + $rarg->C;
    }
    return($rslt);
  }
  
  # Frame - Frame = Frame
  # 'str' - Frame = PT     (passed off to PT.pm after PT->new('str') is made)
  # Frame - anything else is not supported yet
  sub _sub {
    my ($larg, $rarg, $srvr) = @_; my $rslt;
    $larg = Time::PT->new($larg) if($srvr);
    if(ref($larg) && $larg->isa('Time::PT')) {
      $rslt = $larg - $rarg; # pass off calculation to PT.pm
    } else {
      $rarg = Time::Frame->new($rarg) unless(ref($rarg) && $rarg->isa('Time::Frame'));
      $rslt = Time::Frame->new();
      $rslt->{'_zone'}    = $larg->z - $rarg->z;
      $rslt->{'_jink'}    = $larg->j - $rarg->j;
      $rslt->{'_frame'}   = $larg->f - $rarg->f;
      $rslt->{'_second'}  = $larg->s - $rarg->s;
      $rslt->{'_minute'}  = $larg->i - $rarg->i;
      $rslt->{'_hour'}    = $larg->h - $rarg->h;
      $rslt->{'_day'}     = $larg->D - $rarg->D;
      $rslt->{'_month'}   = $larg->O - $rarg->O;
      $rslt->{'_year'}    = $larg->Y - $rarg->Y;
      $rslt->{'_century'} = $larg->C - $rarg->C;
    }
    return($rslt);
  }
  
  sub _color_fields {
    my $self = shift;
    my $fstr = shift || ' ' x 10; $fstr =~ s/^0+// if(length($fstr) <= 7);
    my $ctyp = shift || 'Simp';
    my @clrz = (); my $coun = 0; my $rstr = '';
    if     ($ctyp =~ /^s/i) { # simp color codes
      @clrz = @{$self->_field_colors('simp')};
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun++]; }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(8 - length($fstr) + $coun++)]; }
      }
    } elsif($ctyp =~ /^h/i) { # HTML link && font color tag delimiters
      @clrz = @{$self->_field_colors('html')};
      $_    = '<font color="#' . $_ . '">' foreach(@clrz);
      $rstr = '<a href="http://Ax9.Org/pt?fr=' . $fstr . '">';
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1) . '</font>'; }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(8 - length($fstr) + $coun)] . substr($fstr, $coun++, 1) . '</font>'; }
      }
      $rstr .= '</a>';
    } elsif($ctyp =~ /^4/i) { # 4nt prompt needs verbose color codes
      @clrz = @{$self->_field_colors('4nt')};
      for(my $i=0; $i<@clrz; $i++) {
        $clrz[$i] = ' & color ' . $clrz[$i] . ' & echos ';
      }
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1); }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun)] . substr($fstr, $coun++, 1); }
      }
    } else { # ANSI escapes
      @clrz = @{$self->_field_colors('ansi')};
      if($ctyp =~ /^z/i) { # zsh prompt needs delimited %{ ANSI %}
        for(my $i=0; $i<@clrz; $i++) { $clrz[$i] = '%{' . $clrz[$i] . '%}'; }
      }
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1); }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(8 - length($fstr) + $coun)] . substr($fstr, $coun++, 1); }
      }
    }
    return($rstr);
  }
  
  # Time::Frame object constructor as class method or copy as object method.
  # First param can be ref to copy.  Not including optional ref from 
  #   copy, default is no params to create a new empty Frame object.
  # If params are supplied, they must be a single key && a single value.
  # The key must be one of the following 3 types of constructor 
  #   initialization mechanisms:
  #    -1) <packedB64InitStringImplies'str'>(eg. '0A1B2C3D4E')
  #     0) 'str'  => <packedB64InitString>  (eg. 'str'  => '0A1B2C3D4E')
  #     1) 'list' => <arrayRef>             (eg. 'list' => [0, 1, 2..9])
  #     2) 'hash' => <hashRef>              (eg. 'hash' => {'jink' => 8})
  sub new { 
    my ($nvkr, $ityp, $idat) = @_; 
    my $nobj = ref($nvkr);
    my $clas = $ityp;
    $clas = $nobj || $nvkr if(!defined($ityp) || $ityp !~ /::/);
    my $self = Time::Fields->new($clas);
    my @attz = $self->_attribute_names();
    foreach my $attr ( @attz ) { #$self->_attribute_names() ) { 
  #    $self->{$attr} = $self->_default_value($attr); # init defaults
      $self->{$attr} = $nvkr->{$attr} if($nobj);     #  && copy if supposed to
    }
    if(defined($ityp) && $ityp !~ /::/) { # there were initialization params
      ($ityp, $idat) = ('str', $ityp) unless(defined($idat));
      if($ityp =~ /^verbose$/i) { # handle 'verbose' differently
        # verbose string param has decimal numbers followed by full field names
        while($idat =~ s/(\d+)\s*(\w+)//) {
          my($fval, $fnam) = ($1, lc($2));
          $fnam =~ s/s$//; # strip ending 's'
  # should do some testing of fnam to turn into closest _attribute_name if ! one
          if($fnam =~ /^w/) { $self->{'_day'}        += (7 * $fval); }
          else              { $self->{('_' . $fnam)} += $fval; }
        }
      } elsif($ityp =~ /^s/i && length($idat) < 9) { # handle small 'str' differently
        # small str param grows left from frame field if shorter than 9 chars
        my $ilen = length($idat);
        for(my $i = (8-$ilen); $i < 8; $i++) {
          if($idat =~ s/^(.)//) {
            $self->{$attz[$i]} = b10($1); # break down str
          }
        }
      } else {
        foreach my $attr ( @attz ) {
          if     ($ityp =~ /^s/i) {    # 'str'
            $self->{$attr} = b10($1) if($idat =~ s/^(.)//);  # break down string
          } elsif($ityp =~ /^[la]/i) { # 'list' or 'array'
            $self->{$attr} = shift( @{$idat} ) if(@{$idat}); # shift list vals
          } elsif($ityp =~ /^h/i) {    # 'hash'
            # do some searching to find hash key that matches
            foreach(keys(%{$idat})) {
              if($attr =~ /$_/) {
                $self->{$attr} = $idat->{$_};
                delete($idat->{$_});
              }
            }
          } else { # undetected init type
            croak "!*EROR*! Time::Frame::new initialization type: $ityp did not match 'str', 'list', or 'hash'!\n";
          }
        }
      }
    }
    return($self);
  }
  
  sub total_frames { # return the integer number of frames in a Time::Frame obj
    my $self = shift; my $totl = 0;
    $totl += ($self->j() * (1.0 / 60.0));
    $totl +=  $self->f();
    $totl += ($self->s() * 60);
    $totl += ($self->m() * 60 * 60);
    $totl += ($self->h() * 60 * 60 * 60);
    $totl += ($self->D() * 60 * 60 * 60 * 24);
    $totl += ($self->M() * 60 * 60 * 60 * 24 * 30.4368537808642);
    $totl += ($self->Y() * 60 * 60 * 60 * 24 * 365.24225);
    $totl += ($self->C() * 60 * 60 * 60 * 24 * 365.24225 * 100);
    return($totl);
  }
  
  #sub AUTOLOAD { # methods (created as necessary)
  #  no strict 'refs';
  #  my ($self, $nwvl) = @_;
  #
  #  # normal set_/get_ methods
  #
  #  if     ($AUTOLOAD =~ /.*::[sg]et(_\w+)/i) {
  #    my $atnm = lc($1);
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1);
  #    return($self->{$atnm});
  #  # use_??? to set/get field filters
  #  } elsif($AUTOLOAD =~ /.*::(use_\w+)/i) {
  #    my $atnm = '__' . lc($1);
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1);
  #    return($self->{$atnm});
  #  # Alias methods which must be detected before sweeps
  #  } elsif($AUTOLOAD =~ /.*::time$/i) { 
  #    *{$AUTOLOAD} = sub { return($self->hms()); };
  #    return($self->hms());
  #  } elsif($AUTOLOAD =~ /.*::dt$/i) { 
  #    *{$AUTOLOAD} = sub { return($self->CYMDhmsfjz()); };
  #    return($self->CYMDhmsfjz());
  #  } elsif($AUTOLOAD =~ /.*::mday$/i) { my $atnm = '_day';
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1); return($self->{$atnm});
  #  # all joint field methods (eg. YMD(), hms(), foo(), etc.
  #  } elsif($AUTOLOAD =~ /.*::([CYMODhmisfjz][CYMODhmisfjz]+)$/i) { 
  #    my @fldl = split(//, $1); 
  #    my ($self, @nval) = @_; my @rval = (); my $atnm = ''; my $rgex;
  #    # handle Month / minute exceptions
  #    for(my $i=0; $i<$#fldl; $i++) {
  #      $fldl[$i + 1] = 'O' if($fldl[$i] =~ /[yd]/i && $fldl[$i + 1] eq 'm');
  #      $fldl[$i    ] = 'O' if($fldl[$i] eq 'm'     && $fldl[$i + 1] =~ /[yd]/i);$      $fldl[$i    ] = 'O' if($fldl[$i] eq 'M');
  #      $fldl[$i    ] = 'i' if($fldl[$i] eq 'm');
  #    }
  #    *{$AUTOLOAD} = sub { 
  #      my ($self, @nval) = @_; my @rval = (); 
  #      for(my $i=0; $i<@fldl; $i++) {
  #        foreach my $attr ($self->_attribute_names()){
  #          my $mtch = $self->_attribute_match($attr);
  #          if(defined($mtch) && $fldl[$i] =~ /^$mtch/i) {
  #            $self->{$attr} = $nval[$i] if($i < @nval);
  #            push(@rval, $self->{$attr});
  #          }
  #        }
  #      }
  #      return(@rval);
  #    };
  #    for(my $i=0; $i<@fldl; $i++) {
  #      foreach my $attr ($self->_attribute_names()){
  #        my $mtch = $self->_attribute_match($attr);
  #        if(defined($mtch) && $fldl[$i] =~ /$mtch/i) {
  #          $self->{$attr} = $nval[$i] if($i < @nval);
  #          push(@rval, $self->{$attr});
  #        }
  #      }
  #    }
  #    return(@rval);
  #  # sweeping matches to handle partial keys
  #  } elsif($AUTOLOAD =~ /.*::[-_]?([CYMODhmisfjz])(.)?/i) { 
  #    my ($atl1, $atl2) = ($1, $2); my $atnm;
  #    $atl1 = 'O' if($atl1 eq 'm' && defined($atl2) && lc($atl2) eq 'o');
  #    $atl1 = 'i' if($atl1 eq 'M' && defined($atl2) && lc($atl2) eq 'i');
  #    $atl1 = 'O' if($atl1 eq 'M');
  #    $atl1 = 'i' if($atl1 eq 'm');
  #    foreach my $attr ($self->_attribute_names()) {
  #      my $mtch = $self->_attribute_match($attr);
  #      $atnm = $attr if(defined($mtch) && $atl1 =~ /$mtch/i);
  #    }
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1);
  #    return($self->{$atnm});
  #  } else {
  #    croak "No such method: $AUTOLOAD\n";
  #  }
  #}
  
  sub DESTROY { } # do nothing but define in case && to calm warning in test.pl
  
  127;
TIME_FRAME

$fatpacked{"Time/JulianDay.pm"} = <<'TIME_JULIANDAY';
  package Time::JulianDay;
  
  require 5.000;
  
  use Carp;
  use Time::Timezone;
  
  @ISA = qw(Exporter);
  @EXPORT = qw(julian_day inverse_julian_day day_of_week 
  	jd_secondsgm jd_secondslocal 
  	jd_timegm jd_timelocal 
  	gm_julian_day local_julian_day 
  	);
  @EXPORT_OK = qw($brit_jd);
  
  use strict;
  use integer;
  
  # constants
  use vars qw($brit_jd $jd_epoch $jd_epoch_remainder $VERSION);
  
  $VERSION = 2011.0505;
  
  # calculate the julian day, given $year, $month and $day
  sub julian_day
  {
      my($year, $month, $day) = @_;
      my($tmp);
  
      use Carp;
  #    confess() unless defined $day;
  
      $tmp = $day - 32075
        + 1461 * ( $year + 4800 - ( 14 - $month ) / 12 )/4
        + 367 * ( $month - 2 + ( ( 14 - $month ) / 12 ) * 12 ) / 12
        - 3 * ( ( $year + 4900 - ( 14 - $month ) / 12 ) / 100 ) / 4
        ;
  
      return($tmp);
  
  }
  
  sub gm_julian_day
  {
      my($secs) = @_;
      my($sec, $min, $hour, $mon, $year, $day, $month);
      ($sec, $min, $hour, $day, $mon, $year) = gmtime($secs);
      $month = $mon + 1;
      $year += 1900;
      return julian_day($year, $month, $day)
  }
  
  sub local_julian_day
  {
      my($secs) = @_;
      my($sec, $min, $hour, $mon, $year, $day, $month);
      ($sec, $min, $hour, $day, $mon, $year) = localtime($secs);
      $month = $mon + 1;
      $year += 1900;
      return julian_day($year, $month, $day)
  }
  
  sub day_of_week
  {
  	my ($jd) = @_;
          return (($jd + 1) % 7);       # calculate weekday (0=Sun,6=Sat)
  }
  
  
  # The following defines the first day that the Gregorian calendar was used
  # in the British Empire (Sep 14, 1752).  The previous day was Sep 2, 1752
  # by the Julian Calendar.  The year began at March 25th before this date.
  
  $brit_jd = 2361222;
  
  # Usage:  ($year,$month,$day) = &inverse_julian_day($julian_day)
  sub inverse_julian_day
  {
          my($jd) = @_;
          my($jdate_tmp);
          my($m,$d,$y);
  
          carp("warning: julian date $jd pre-dates British use of Gregorian calendar\n")
                  if ($jd < $brit_jd);
  
          $jdate_tmp = $jd - 1721119;
          $y = (4 * $jdate_tmp - 1)/146097;
          $jdate_tmp = 4 * $jdate_tmp - 1 - 146097 * $y;
          $d = $jdate_tmp/4;
          $jdate_tmp = (4 * $d + 3)/1461;
          $d = 4 * $d + 3 - 1461 * $jdate_tmp;
          $d = ($d + 4)/4;
          $m = (5 * $d - 3)/153;
          $d = 5 * $d - 3 - 153 * $m;
          $d = ($d + 5) / 5;
          $y = 100 * $y + $jdate_tmp;
          if($m < 10) {
                  $m += 3;
          } else {
                  $m -= 9;
                  ++$y;
          }
          return ($y, $m, $d);
  }
  
  {
  	my($sec, $min, $hour, $day, $mon, $year) = gmtime(0);
  	$year += 1900;
  	if ($year == 1970 && $mon == 0 && $day == 1) {
  		# standard unix time format
  		$jd_epoch = 2440588;
  	} else {
  		$jd_epoch = julian_day($year, $mon+1, $day);
  	}
  	$jd_epoch_remainder = $hour*3600 + $min*60 + $sec;
  }
  
  sub jd_secondsgm
  {
  	my($jd, $hr, $min, $sec) = @_;
  
  	my($r) =  (($jd - $jd_epoch) * 86400 
  		+ $hr * 3600 + $min * 60 
  		- $jd_epoch_remainder);
  
  	no integer;
  	return ($r + $sec);
  	use integer;
  }
  
  sub jd_secondslocal
  {
  	my($jd, $hr, $min, $sec) = @_;
  	my $jds = jd_secondsgm($jd, $hr, $min, $sec);
  	return $jds - tz_local_offset($jds);
  }
  
  # this uses a 0-11 month to correctly reverse localtime()
  sub jd_timelocal
  {
  	my ($sec,$min,$hours,$mday,$mon,$year) = @_;
  	$year += 1900 unless $year > 1000;
  	my $jd = julian_day($year, $mon+1, $mday);
  	my $jds = jd_secondsgm($jd, $hours, $min, $sec);
  	return $jds - tz_local_offset($jds);
  }
  
  # this uses a 0-11 month to correctly reverse gmtime()
  sub jd_timegm
  {
  	my ($sec,$min,$hours,$mday,$mon,$year) = @_;
  	$year += 1900 unless $year > 1000;
  	my $jd = julian_day($year, $mon+1, $mday);
  	return jd_secondsgm($jd, $hours, $min, $sec);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::JulianDay -- Julian calendar manipulations
  
  =head1 SYNOPSIS
  
  	use Time::JulianDay
  
  	$jd = julian_day($year, $month_1_to_12, $day)
  	$jd = local_julian_day($seconds_since_1970);
  	$jd = gm_julian_day($seconds_since_1970);
  	($year, $month_1_to_12, $day) = inverse_julian_day($jd)
  	$dow = day_of_week($jd) 
  
  	print (Sun,Mon,Tue,Wed,Thu,Fri,Sat)[$dow];
  
  	$seconds_since_jan_1_1970 = jd_secondslocal($jd, $hour, $min, $sec)
  	$seconds_since_jan_1_1970 = jd_secondsgm($jd, $hour, $min, $sec)
  	$seconds_since_jan_1_1970 = jd_timelocal($sec,$min,$hours,$mday,$month_0_to_11,$year)
  	$seconds_since_jan_1_1970 = jd_timegm($sec,$min,$hours,$mday,$month_0_to_11,$year)
  
  =head1 DESCRIPTION
  
  JulianDay is a package that manipulates dates as number of days since 
  some time a long time ago.  It's easy to add and subtract time
  using julian days...  
  
  The day_of_week returned by day_of_week() is 0 for Sunday, and 6 for
  Saturday and everything else is in between.
  
  =head1 ERRATA
  
  Time::JulianDay is not a correct implementation.  There are two
  problems.  The first problem is that Time::JulianDay only works
  with integers.  Julian Day can be fractional to represent time
  within a day.  If you call inverse_julian_day() with a non-integer
  time, it will often give you an incorrect result.
  
  The second problem is that Julian Days start at noon rather than
  midnight.  The julian_day() function returns results that are too
  large by 0.5.
  
  What to do about these problems is currently open for debate.  I'm
  tempted to leave the current functions alone and add a second set
  with more accurate behavior.
  
  There is another implementation in Astro::Time that may be more accurate.
  
  =head1 GENESIS
  
  Written by David Muir Sharnoff <cpan@dave.sharnoff.org> with help from
  previous work by 
  Kurt Jaeger aka PI <zrzr0111@helpdesk.rus.uni-stuttgart.de>
   	based on postings from: Ian Miller <ian_m@cix.compulink.co.uk>;
  Gary Puckering <garyp%cognos.uucp@uunet.uu.net>
  	based on Collected Algorithms of the ACM ?;
  and the unknown-to-me author of Time::Local.
  
  =head1 LICENSE
  
  Copyright (C) 1996-1999 David Muir Sharnoff.  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
  
TIME_JULIANDAY

$fatpacked{"Time/PT.pm"} = <<'TIME_PT';
  # 2CN4sip - Time::PT.pm (PipTime) created by Pip@CPAN.Org to define 
  #   simple objects for storing instants in time.
  # Desc: PT describes a simple object which encapsulates 10 fields:
  #     Century, Year, Month, Day, hour, minute, second, frame, jink, zone
  #   where frame is normally 1/60th-of-a-second && jink is normally 
  #   1/60th-of-a-frame.  The objects describe a high-precision time-
  #   instant with fields in decending order of precision such that 
  #   alphabetic listings will (typically) show time ascension && field 
  #   arithmetic can be easily performed.  PT objects can
  #   be added to / subtracted from Time::Frame objects to yield 
  #   new specific PT instants.
  #     The common use of PT is for a simple `pt` utility to 
  #   en/decode dates && times using seven (7) Base64 characters.
  #     1st: '0A1B2C3'
  #     2nd: 'Yd:2003,j:A7_,M:a3I' or 'f:3aL9.eP' 
  #     if field name ends with d, value is read as decimal nstd of default b64.
  #     Third way is super verbose decimal strings:
  #       '15 years, 3 months, 7 weeks, 4 jinx' can use any (or none) sep but :
  #     4th is hash
  #     Total Jinx possible for PT: 1,680,238,080,000,000 (1.7 quatrillion)
  #           JnxPTEpoch -> `pt __nWO0000` -> Midnight Jan. 1 7039 BCE
  #              PTEpoch -> `pt  _nWO`     -> Midnight Jan. 1 1361  CE
  #   PT members:
  #     new inits either with pt-param, expanded, or empty
  #
  #       epoch_(seconds|frames|jinx)() methods (optional frames/jinx as floats)
  #     ptepoch_(seconds|frames|jinx)() methods 
  #       (since ptEpoch (`pt _nWO` Midnight, Jan1,1361))
  #     settle fields with options (like return new Frame object with only 
  #       total secs of old)
  #     re-def frame as other than 60th-of-a-second
  #     re-def jink  as other than 60th-of-a-frame
  #       eg. def f && j limits as 31.6227766016838 (sqrt(1000)) for ms jinx
  #           or just def f as 1000 for exactly ms frames
  #     allow month/year modes to be set to avg or relative
  #
  #  My Base64 encoding uses characters: 0-9 A-Z a-z . _  since I don't like
  #    having spaces or plusses in my time strings.  I need times to be easy to
  #    append to filenames for very precise, consice, time-stamp versioning.
  #  Each encoded character represents (normally) just a single date or time 
  #    field.  All fields are 0-based except Month && Day.  The fields are:
  #      Year-2000, Month, Day, Hour, Minute, Second, Frame (60th-of-a-second)
  #  There are three (3) exceptions to the rule that each character only
  #    represents one date or time field.  The bits are there so... why not? =)
  #  0) Each 12 added to the Month adds  64 to the Year.
  #  1)      24 added to the Hour  adds 320 to the Year.
  #  2)      31 added to the Day   makes the year negative just before adding 
  #            2000.
  #  So with all this, any valid pt (of 7 b64 characters) represents a unique 
  #    instant (precise down to a Frame [60th-of-a-second]) that occurred or 
  #    will occur between the years 1361 && 2639 (eg. New Year's Day of each 
  #    of those years would be '_nWO' && '_n1O').  These rules break down as:
  # Hour   Day  Month     Year    YearWith2000
  # 24-47 32-62 49-60  -639- -576  1361-1424
  #             37-48  -575- -512  1425-1488
  #             25-36  -511- -448  1489-1552
  #             13-24  -447- -384  1553-1616
  #              1-12  -383- -320  1617-1680
  #  0-23 32-62 49-60  -319- -256  1681-1744
  #             37-48  -255- -192  1745-1808
  #             25-36  -191- -128  1809-1872
  #             13-24  -127-  -64  1873-1936
  #              1-12   -63-   -0  1937-2000
  #  0-23  1-31  1-12     0-   63  2000-2063
  #             13-24    64-  127  2064-2127
  #             25-36   128-  191  2128-2191
  #             37-48   192-  255  2192-2255
  #             49-60   256-  319  2256-2319
  # 24-47  1-31  1-12   320-  383  2320-2383
  #             13-24   384-  447  2384-2447
  #             25-36   448-  511  2448-2511
  #             37-48   512-  575  2512-2575
  #             49-60   576-  639  2576-2639
  # Notz:
  #  PT + Frame can become the core of a new input language which accounts
  #    for time.  It could be game sequences like a fireball that can be rolled
  #    from d->df && df->f only at a certain speed ... but then also later
  #    maybe time-sensitive computer input like typematic key repeat rate but
  #    configurable... smarter?  The combinatorics on the X-Box Live pswd is
  #    8**4 == 4096 (butn: u,d,l,r,x,y,L,R) so even exhausting the search space
  #    (assuming you're too wise for a smpl likely 4-char sequence) could be
  #    finished manually in about 9 hours if you complete a test cycle each
  #    8 seconds.  Automated would need programmable circuit... plug that
  #    thang into USB && make an easy sequencer PT+Frame- based IF to perform!
  #    So cool!
  #  Could create an easy IF to setup any sort of practice scenario,
  #    programmable pad behavior, or even store replays as device inputs &&
  #    feed them back in... woohoo that's fscking cool!  GameOver specialty =)
  #    umm it would basically need the same IF as a fighting game tool hehe =).
  #  Don't need Math::BigInt to store pt epoch seconds (pte's) because perl's 
  #    floats already have enough precision to store them.  Use the fractional 
  #    part of those values to store 60ths && don't use builtin timelocal 
  #    functions which only accept 1970-2036 (or whatever limited) epoch 
  #    seconds (only 32-bit ints or something =( ).
  #  Interaction with other Time modules: 
  #    Time::Period  - just have an Epoch export option && Period can use it
  #    Time::Avail   - doesn't seem useful to my purposes
  #    Time::Piece   - might be nice to mimic this module's object interface
  #    Time::Seconds - handy for dealing with lots of seconds but about 60ths?
  #  old 5-char pt examples: (update these when there's time)
  # Xmpl: `pt 01`        == localtime(975657600) # seconds since Epoch
  #     `pt 1L7Mu`       == unpack time (Sun Jan 21 07:22:56 2001)
  #     `pt _VNxx`       == localtime(1143878399)
  #     `pt pt`          == unpack current pt (akin to `pt `pt``)
  #     `pt e`           == localtime  (eg. Thu Jan 21 07:22:56 2001)
  #     `pt e e`         == current epoch seconds
  #     `pt 1L7Mu e`     == convert from pt to epoch (980090576)
  #     `pt 975657600 E` == convert from Epoch seconds to pt (01)
  #     `pt Jan 21, 2001 07:22:56`    -> 1L7Mu
  #     `pt Sun Jan 21 07:22:56 2001` -> 1L7Mu
  #     `pt 1L7Mu cmp FEET0`          -> lt 
  #     `pt FEET0 cmp 1L7Mu`          -> gt 
  #     `pt 2B cmp 2B`                -> eq
  #       timelocal($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
  
  =head1 NAME
  
  Time::PT - objects to store an instant in time
  
  =head1 VERSION
  
  This documentation refers to version 1.2.565EHOV of 
  Time::PT, which was released on Sun Jun  5 14:17:24:31 2005.
  
  =head1 SYNOPSIS
  
    use Time::PT;
    
    my $f = Time::PT->new();
    
    print "PipTime is: $f\n";
    print 'The Day-of-Week today is: ', $f->dow(), "\n";
  
  =head1 DESCRIPTION
  
  By default, Time::PT stores time descriptions precise to 60ths-
  of-a-second (0.016667 seconds).  The groundwork has been laid
  for sub-millisecond precision to be included later.
  
  This module has been adapted from the L<Time::Piece> module 
  written by Matt Sergeant <matt@sergeant.org> && Jarkko 
  Hietaniemi <jhi@iki.fi>.  Time::PT inherits base 
  data structure && object methods from L<Time::Fields>.  
  PT was written to simplify storage && calculation 
  of encoded, yet distinct && human-readable, time data 
  objects.
  
  This module (Time::PT) does not replace the standard localtime &&
  gmtime functions like L<Time::Piece> but Time::PT objects behave
  almost identically to L<Time::Piece> objects otherwise (since it
  was adapted from... I said that already =) ).
  
  =head1 2DO
  
  =over 2
  
  =item - mk interoperable w/ Time::Seconds objects
  
  =item - add Time::Zone stuff to use && match zone field reasonably
  
  =item - replace legacy pt() with tested new() wrapper && fix all apps to
            use objs instead of local pt()
  
  =item - flesh out constructor init data parsing && formats supported
  
  =item - consider epoch functions like _epoch([which epoch]) or individuals
            like _jinx_epoch()
  
  =item - mk PT->new able to create from different 'epoch' init types
  
  =item - fix weird 0 month && 0 day problems
  
  =item -     What else does PT need?
  
  =back
  
  =head1 WHY?
  
  The reason I created PT was that I have grown so enamored with
  Base64 representations of everything around me that I was 
  compelled to write a simple clock utility ( `pt` ) using Base64.
  This demonstrated the benefit to be gained from time objects with
  distinct fields && configurable precision.  Thus, L<Time::Fields>
  was written to be the abstract base class for:
  
    Time::Frame  ( creates objects which represent spans    of time )
        && 
    Time::PT     ( creates objects which represent instants in time )
  
  =head2 HOW?
  
  I've made up some silly sentences as mnemonic devices to help me 
  remember every 4th uppercase Base64 character:
  
    Can      12   Noon       MonthOfYear will be less or equal to 'C'.
    Goats    16   4 PM
    Keep     20   8 PM
    Oats     24   Midnight   HourOfDay   will be less than        'O'.
    Some     28  
    Where?   32              DayOfMonth  will be less than        'W'.
  
    Cool    COW (Month Hour Day thresholds)
    Guys    Girls
    Keep    Keep
    On      On                   Off
    Sayin'  Sayin'      Sippin'  Sea
    Wassup  WeeDoggies  Water    Water
  
  =head1 USAGE
  
  Many of Time::PT's methods have been patterned after the excellent
  L<Time::Piece> module written by Matt Sergeant <matt@sergeant.org>
  && Jarkko Hietaniemi <jhi@iki.fi>.
  
  =head2 new(<InitType>, <InitData>)
  
  Time::PT's constructor can be called
  as a class method to create a brand new object or as an object 
  method to copy an existing object.  Beyond that, new() can 
  initialize PT objects 3 different ways:
  
    * <packedB64InitStringImplies'str'>
      eg. Time::PT->new('3C79jo0');
    * 'str'  => <packedB64InitString>
      eg. Time::PT->new('str'  => '0A1B2C3D4E');
    * 'list' => <arrayRef>
      eg. Time::PT->new('list' => [0, 1, 2..9]);
    * 'hash' => <hashRef>
      eg. Time::PT->new('hash' => {'jink' => 8, 'year' => 2003})
  
  =head2 color(<DestinationColorTypeFormat>)
  
  This is an object member
  which will join Base64 representations of each field that has
  been specified in use() && joins them with color-codes or color
  escape sequences with formats for varied uses.  Currently
  available DestinationColorTypeFormats are:
  
    'ANSI'  # eg. \e[1;32m
    'zsh'   # eg. %{\e[1;33m%}
    'HTML'  # eg. <a href="http://Ax9.Org/pt?"><font color="#FF1B2B">
    '4NT'   # eg. color 09 & 
    'Simp'  # eg. RbobYbGbCbUbPb
  
  =head2 pt
  
  This function is the legacy procedural version of my command-line
  PipTime utility.  It will be removed in the near future when the
  object methods fully replace all the old behavior && have been 
  tested sufficiently.
  
  This function && the following ptcc() are the only functions
  exported when Time::PT is used.
  
  =head2 ptcc(<DestinationColorTypeFormat>)
  
  Returns the Simp color code string appropriate for pt (PipTime) data.
  
    Format   Returned color code string
     'k'     the background will change along with the foreground for standard
               time-of day elements (ie. hms on a dark blue background)
     'f'     color codes for the expanded pt format 
               (eg. color codes corresponding to Sun Jan  4 12:41:48:13 2004)
  
  This function && the previous legacy pt() are the only functions
  exported when Time::PT is used.
  
  The following methods allow access to individual fields of 
  Time::PT objects:
  
    $t->C  or  $t->century
    $t->Y  or  $t->year
    $t->M  or  $t->month
    $t->D  or  $t->day
    $t->h  or  $t->hour
    $t->m  or  $t->minute
    $t->s  or  $t->second
    $t->f  or  $t->frame
    $t->j  or  $t->jink
    $t->z  or  $t->zone
  
  Please see L<Time::Fields> for further description of field 
  accessor methods.
  
  After importing this module, when you use localtime or gmtime in a
  scalar context, you DO NOT get a special Time::PT object like you
  would when using L<Time::Piece>.  This module relies on a new() 
  constructor instead.  The following methods are available on 
  Time::PT objects though && remain as similar to L<Time::Piece>
  functionality as makes sense.
  
    $t->frm                 # also as $t->frame && $t->subsecond
    $t->sec                 # also available as $t->second
    $t->min                 # also available as $t->minute
    $t->hour                # 24 hour
    $t->mday                # also available as $t->day_of_month
    $t->mon                 # 1 = January
    $t->_mon                # 0 = January
    $t->monname             # Feb
    $t->month               # same as $t->mon
                   # *NOTE* The above definition ( of $t->month() ) is 
                   # different from the Time::Piece interface which defines
                   # month() the same as monname() instead of mon().
    $t->fullmonth           # February
    $t->year                # based at 0 (year 0 AD is, of course 1 BC)
    $t->_year               # year minus 1900
    $t->yy                  # 2 digit year
    $t->wday                # 1 = Sunday
    $t->_wday               # 0 = Sunday
    $t->day_of_week         # 0 = Sunday
    $t->wdayname            # Tue
    $t->day                 # same as mday
                   # *NOTE* Similar to month(), I've defined day() 
                   # differently from Time::Piece which makes it the same
                   # as wdayname() instead of mday().
    $t->fullday             # Tuesday
    $t->yday                # also available as $t->day_of_year, 0 = Jan 01
    $t->isdst               # also available as $t->daylight_savings
  
  The following functions return a list of the named fields.  The
  return value can be joined with any desirable delimiter like:
  
    join(':', $t->hms);
    join($t->time_separator, $t->hms);
  
  but the functions also can take a list of parameters to update
  the corresponding named fields like:
  
    $t->YMD( 2003, 12, 8 ) # assigns new date of December 8th, 2003 to $t
  
  Following are some useful functions && comments of sample return values:
  
    $t->hms                 # [12, 34, 56]
    $t->hmsf                # [12, 34, 56, 12]
    $t->time                # same as $t->hmsf
  
    $t->ymd                 # [2000,  2, 29]
    $t->date                # same as $t->ymd
    $t->mdy                 # [ 2, 29, 2000]
    $t->dmy                 # [29,  2, 2000]
    $t->datetime            # 2000-02-29T12:34:56            (ISO 8601)
    $t->expand              # Tue Feb 29 12:34:56:12 2000
    $t->cdate               # same as $t->expand
    $t->compress            # 02TCYuC
    "$t"                    # same as $t->compress
  
    $t->is_leap_year        # true if it is
    $t->month_last_day      # 28-31
  
    $t->time_separator($s)  # set the default separator (default ":")
    $t->date_separator($s)  # set the default separator (default "-")
    $t->day_list(@days)     # set the default weekdays
    $t->mon_list(@days)     # set the default months
  
  =head2 Local Locales
  
  Both wdayname() && monname() can accept the same list parameter 
  as day_list() && mon_list() respectively for temporary help with
  simple localization.
  
    my @days = ( 'Yom Rishone', 'Yom Shayni', 'Yom Shlishi', 'Yom Revi\'i', 
                 'Yom Khahmishi', 'Yom Hashishi', 'Shabbat' );
  
    my $hebrew_day = pt->wdayname(@days);
                   # pt->monname() can be used similarly
  
  To update the global lists, use:
  
    Time::PT::day_list(@days);
      &&
    Time::PT::mon_list(@months);
  
  =head2 Calculations
  
  PT object strings (both in normal initialization && printing) grow
  left-to-right starting from the Year to specify whatever precision
  you need while Frame objects grow right-to-left from the frame field.
  
  It's possible to use simple addition and subtraction of objects:
  
    use Time::Frame;
    
    my $cur_pt       = Time::PT->new();# Dhmsf
    my $one_week     = Time::Frame->new('70000');
    my $one_week_ago = $cur_pt - $one_week;
  
  If a calculation is done with a raw string parameter instead of an
  instantiated object, the most likely appropriate object 
  constructor is called on it.  These init strings must adhere to
  the implied 'str' format for auto-creating objects;  I aim to
  support a much wider array of operations && to make this module
  smoothly interoperate with both L<Time::Piece> && L<Time::Seconds>
  someday but not yet.
  
    my $cur_pt             = Time::PT->new();
    my $half_hour_from_now = $cur_pt + 'U00';
  
  The following are valid (where $t0 and $t1 are Time::PT objects
  && $f is a Time::Frame object):
  
    $t0 - $t1;  # returns Time::Frame object
    $t0 - '63'; # returns Time::PT object
    $t0 + $f;   # returns Time::PT object
  
  =head2 Comparisons
  
  All normal numerical && string comparisons should work reasonably on
  Time::PT objects: 
  
    "<",  ">",  "<=", ">=", "<=>", "==" &&  "!="
    "lt", "gt", "le", "ge", "cmp", "eq" and "ne"
  
  =head2 YYYY-MM-DDThh:mm:ss
  
  The ISO 8601 standard defines the date format to be YYYY-MM-DD, and
  the time format to be hh:mm:ss (24 hour clock), and if combined,
  they should be concatenated with date first and with a capital 'T'
  in front of the time.
  
  =head2 Week Number
  
  The ISO 8601 standard specifies that weeks begin on Monday and the first
  week of the year is the one that includes both January 4th and the
  first Thursday of the year.  In other words, if the first Monday of
  January is the 2nd, 3rd, or 4th, the preceding days are part of the 
  final week of the prior year.  Week numbers range from 1 to 53.
  
  =head1 NOTES
  
  Whenever individual Time::PT attributes are going to be 
  printed or an entire object can be printed with multi-colors,
  the following mapping should be employed whenever possible:
  
             D      Century -> DarkRed
             A      Year    -> Red
             T      Month   -> Orange
             E      Day     -> Yellow
                     hour   -> Green
              t      minute -> Cyan
              i      second -> Blue
              m      frame  -> Purple
              e      jink   -> DarkPurple
                     zone   -> Grey or White
  
  Please see the color() member function in the USAGE section.
  
  There's some weird behavior for PipTimes created with a zero month
  or day field since both are 1-based.  I aim to fix all these bugs
  but be warned that this issue may be causing math errors for a bit.
  
  I hope you find Time::PT useful.  Please feel free to e-mail
  me any suggestions || coding tips || notes of appreciation 
  ("app-ree-see-ay-shun").  Thank you.  TTFN.
  
  =head1 CHANGES
  
  Revision history for Perl extension Time::PT:
  
  =over 4
  
  =item - 1.2.565EHOV  Sun Jun  5 14:17:24:31 2005
  
  * updated test.pl to work properly with Build.PL as well as Makefile.PL
  
  * updated License, minor version, && precision description
  
  =item - 1.0.42M3ChX  Sun Feb 22 03:12:43:33 2004
  
  * added 4NT option to color codes in Fields && color() members in Frame && PT
  
  * updated POD links && CHANGES chronology
  
  =item - 1.0.41M4cZH  Thu Jan 22 04:38:35:17 2004
  
  * moved pt, fpt, && lspt into bin/ for packaging as EXE_FILES
  
  * added Time::Frame::total_frames method
  
  =item - 1.0.418BGcv  Thu Jan  8 11:16:38:57 2004
  
  * moved Curses::Simp::ptCC into Time::PT::ptcc for PipTime-specific Simp
      Color Codes
  
  * created Time::Fields::_field_colors (centralized base class color codes)
      && updated Frame && PT _color_fields
  
  * added HOW? POD section for mnemonics
  
  =item - 1.0.3CVL3V4  Wed Dec 31 21:03:31:04 2003
  
  * changed PREREQ to not have lib files from this pkg
  
  =item - 1.0.3CQ8ibf  Fri Dec 26 08:44:37:41 2003
  
  * fixed typo && hardcoded path in VERSION_FROM of gen'd Makefile.PL
  
  =item - 1.0.3CNNQHc  Tue Dec 23 23:26:17:38 2003
  
  * combined Fields, Frame, && PT into one pkg
  
  =item - 1.0.3CCA2VC  Fri Dec 12 10:02:31:12 2003
  
  * removed indenting from POD NAME section
  
  =item - 1.0.3CBIQv7  Thu Dec 11 18:26:57:07 2003
  
  * updated test.pl to use normal comments
  
  =item - 1.0.3CB7Vxh  Thu Dec 11 07:31:59:43 2003
  
  * added HTML color option && prepared for release
  
  =item - 1.0.3CA8ipi  Wed Dec 10 08:44:51:44 2003
  
  * built class to inherit from Time::Fields && mimic Time::Piece
  
  =item - 1.0.37VG26k  Thu Jul 31 16:02:06:46 2003
  
  * original version
  
  =back
  
  =head1 INSTALL
  
  Please run:
  
      `perl -MCPAN -e "install Time::PT"`
  
  or uncompress the package && run the standard:
  
      `perl Makefile.PL; make; make test; make install`
  
  =head1 FILES
  
  Time::PT requires:
  
  L<Carp>                to allow errors to croak() from calling sub
  
  L<Math::BaseCnv>       to handle simple number-base conversion
  
  L<Time::DayOfWeek>       also stores global day && month names
  
  L<Time::DaysInMonth>   
  
  L<Time::Fields>        to provide underlying object structure
  
  L<Time::Frame>         to represent spans of time
  
  Time::PT uses (if available):
  
  L<Time::HiRes>         to provide subsecond time precision
  
  L<Time::Local>         to turn epoch seconds back into a real date
  
  L<Time::Zone>           not utilized yet
  
  =head1 SEE ALSO
  
  L<Time::Frame>
  
  =head1 LICENSE
  
  Most source code should be Free!
    Code I have lawful authority over is && shall be!
  Copyright: (c) 2002-2005, Pip Stuart.
  Copyleft : This software is licensed under the GNU General Public
    License (version 2).  Please consult the Free Software Foundation
    (http://FSF.Org) for important information about your freedom.
  
  =head1 AUTHOR
  
  Pip Stuart <Pip@CPAN.Org>
  
  =cut
  
  package Time::PT;
  use strict;
  require      Time::Fields;
  require                   Exporter;
  use base qw( Time::Fields Exporter );
  use vars qw( $AUTOLOAD );
  use Carp;
  use Math::BaseCnv qw( :all );
  use Time::DayOfWeek;
  use Time::DaysInMonth;
  use Time::Frame;
  my $hirs = eval("use   Time::HiRes; 1") || 0;
  my $locl = eval("use   Time::Local; 1") || 0;
  my $zown = eval("use   Time::Zone;  1") || 0;
  #my $simp = eval("use Curses::Simp;  1") || 0;
  our $VERSION     = '1.2.565EHOV'; # major . minor . PipTimeStamp
  our $PTVR        = $VERSION; $PTVR =~ s/^\d+\.\d+\.//; # strip major && minor
  # Please see `perldoc Time::PT` for an explanation of $PTVR.
  our @EXPORT      = qw(pt ptcc);
  use overload 
    q("")  => \&_stringify,
    q(<=>) => \&_cmp_num,
    q(cmp) => \&_cmp_str,
    q(+)   => \&_add,
    q(-)   => \&_sub;
  
  sub _stringify { # cat non-zero b64 PT fields
    my @fdat = $_[0]->CYMDhmsfjz(); 
    my @attz = $_[0]->_attribute_names();
    my $tstr = ''; my $toob = 0; # flag designating field too big
    $fdat[1] -= 2000; # Year adjustment
    foreach(@fdat) {
      $toob = 1 if($_ > 63);
    }
  # Reverse Year shifts back into fields
  #   0) Each 12 added to the Month adds  64 to the Year.
  #   1)      24 added to the Hour  adds 320 to the Year.
  #   2)      31 added to the Day   makes the year negative just before adding 2k
    if(   $fdat[1] <    0) { $fdat[1] *=  -1; $fdat[3] += 31; }
    if(   $fdat[1] >= 320) { $fdat[1] -= 320; $fdat[4] += 24; }
    while($fdat[1] >=  64) { $fdat[1] -=  64; $fdat[2] += 12; }
    if($toob) {
      for(my $i=0; $i<@fdat; $i++) {
        $attz[$i] =~ s/^_(.).*/$1/;
        $attz[$i] = uc($attz[$i]) if($i < 4 || $i == $#fdat);
        $tstr .= $attz[$i] . ':' . $fdat[$i];
        $tstr .= ', ' if($i < $#fdat);
      }
    } else {
      for(my $i=0; $i<@fdat; $i++) {
        if($fdat[$i]) {
          $tstr .= b64($fdat[$i]);
          while($i < 7) { $tstr .= b64($fdat[++$i]); }
        }
      }
    }
    return($tstr);
  }
  
  sub _cmp_num {
    my ($larg, $rarg, $srvr) = @_;
    ($larg, $rarg) = ($rarg, Time::PT->new($larg)) if($srvr); # mk both args PT objects
    $rarg = Time::PT->new($rarg) unless(ref($rarg) && $rarg->isa('Time::PT'));
    if   (($larg->C < $rarg->C) || 
          ($larg->Y < $rarg->Y) || 
          ($larg->O < $rarg->O) || 
          ($larg->D < $rarg->D) || 
          ($larg->h < $rarg->h) || # add z?
          ($larg->i < $rarg->i) || 
          ($larg->s < $rarg->s) || 
          ($larg->f < $rarg->f) || 
          ($larg->j < $rarg->j)) { return(-1); }
    elsif(($larg->C > $rarg->C) || 
          ($larg->Y > $rarg->Y) || 
          ($larg->O > $rarg->O) || 
          ($larg->D > $rarg->D) || 
          ($larg->h > $rarg->h) || # add z?
          ($larg->i > $rarg->i) || 
          ($larg->s > $rarg->s) || 
          ($larg->f > $rarg->f) || 
          ($larg->j > $rarg->j)) { return(1); }
    else                         { return(0); }
  }
  
  sub _cmp_str { 
    my $c = _cmp_num(@_);
    ($c < 0) ? return('lt') : ($c) ? return('gt') : return('eq');
  }
  
  # PT + Frame = PT
  # PT + anything else is not supported yet
  sub _add {
    my ($larg, $rarg, $srvr) = @_;
    my $rslt = Time::PT->new('');
    if($srvr) {
      ($larg, $rarg) = ($rarg, Time::Frame->new($larg));
    }
    unless(ref($rarg) && $rarg->isa('Time::Frame')) {
      $rarg = Time::Frame->new($rarg);
    }
    $rslt->{'_zone'}    = $larg->z + $rarg->z;
    $rslt->{'_jink'}    = $larg->j + $rarg->j;
    $rslt->{'_frame'}   = $larg->f + $rarg->f;
    $rslt->{'_second'}  = $larg->s + $rarg->s;
    $rslt->{'_minute'}  = $larg->i + $rarg->i;
    $rslt->{'_hour'}    = $larg->h + $rarg->h;
    $rslt->{'_day'}     = $larg->D + $rarg->D;
    $rslt->{'_month'}   = $larg->O;
    $rslt->{'_year'}    = $larg->Y;
    $rslt->_sift();
    $rslt->{'_month'}   = $larg->O + $rarg->O;
    $rslt->{'_year'}    = $larg->Y + $rarg->Y;
    $rslt->{'_century'} = $larg->C + $rarg->C;
    $rslt->_sift(1);
    return($rslt);
  }
  
  # PT - Frame = PT
  # PT - PT    = Frame
  # PT - anything else is not supported yet
  sub _sub {
    my ($larg, $rarg, $srvr) = @_; my $rslt;
    if($srvr) { 
      $larg = Time::PT->new($larg);
    }
    if(ref($rarg) && $rarg->isa('Time::PT')) {
      $rslt = Time::Frame->new();
    } else {
      $rarg = Time::Frame->new($rarg) unless(ref($rarg) && $rarg->isa('Time::Frame'));
      $rslt = Time::PT->new('');
    }
    $rslt->{'_zone'}    = $larg->z - $rarg->z;
    $rslt->{'_jink'}    = $larg->j - $rarg->j;
    $rslt->{'_frame'}   = $larg->f - $rarg->f;
    $rslt->{'_second'}  = $larg->s - $rarg->s;
    $rslt->{'_minute'}  = $larg->i - $rarg->i;
    $rslt->{'_hour'}    = $larg->h - $rarg->h;
    $rslt->{'_day'}     = $larg->D - $rarg->D;
    $rslt->{'_month'}   = $larg->O;
    $rslt->{'_year'}    = $larg->Y;
    $rslt->_sift()  if($rslt->isa('Time::PT'));
    $rslt->{'_month'}   = $larg->O - $rarg->O;
    $rslt->{'_year'}    = $larg->Y - $rarg->Y;
    $rslt->{'_century'} = $larg->C - $rarg->C;
    $rslt->_sift(1) if($rslt->isa('Time::PT'));
    return($rslt);
  }
  
  sub _sift { # settles fields into standard ranges (for overflow from add/sub)
    my $self = shift; my $mdon = shift; my $dinf = 0;
    unless($mdon) {
      if($self->{'_jink'} >= $self->{'__jpf'} || 0 > $self->{'_jink'}) {
        $self->{'_jink'}  -= $self->{'__jpf'} if(0 > $self->{'_jink'});
        $self->{'_frame'} += int($self->{'_jink'}  / $self->{'__jpf'});
        $self->{'_jink'}  %= $self->{'__jpf'};
      }
      if($self->{'_frame'} >= $self->{'__fps'} || 0 > $self->{'_frame'}) {
        $self->{'_frame'}  -= $self->{'__fps'} if(0 > $self->{'_frame'});
        $self->{'_second'} += int($self->{'_frame'} / $self->{'__fps'});
        $self->{'_frame'}  %= $self->{'__fps'};
      }
      if($self->{'_second'} >= 60 || 0 > $self->{'_second'}) {
        $self->{'_second'}  -= 60 if(0 > $self->{'_second'});
        $self->{'_minute'}  += int($self->{'_second'} / 60);
        $self->{'_second'}  %= 60;
      }
      if($self->{'_minute'} >= 60 || 0 > $self->{'_minute'}) {
        $self->{'_minute'}  -= 60 if(0 > $self->{'_minute'});
        $self->{'_hour'}    += int($self->{'_minute'} / 60);
        $self->{'_minute'}  %= 60;
      }
      if($self->{'_hour'} >= 24 || 0 > $self->{'_hour'}) {
        $self->{'_hour'}  -= 24 if(0 > $self->{'_hour'});
        $self->{'_day'}   += int($self->{'_hour'} / 24);
        $self->{'_hour'}  %= 24;
      }
      $dinf = 1 unless(defined($self->{'_month'}) && $self->{'_month'});
      $self->{'_month'} = 1 if($dinf);
      while($self->{'_day'} > days_in($self->Y, $self->M) || 0 >  $self->{'_day'}) { 
        if(0 >= $self->{'_day'}) {
          $self->{'_month'}--;
          while($self->{'_month'} < 1) {
            $self->{'_year'}--;
            $self->{'_month'} += 12;
          }
          $self->{'_day'}  += days_in($self->Y, $self->M);
        } else {
          $self->{'_day'}  -= days_in($self->Y, $self->M);
          $self->{'_month'}++;
          while($self->{'_month'} > 12) {
            $self->{'_year'}++;
            $self->{'_month'} -= 12;
          }
        }
      }
      $self->{'_month'}-- if($dinf);
    } else {
      if($self->{'_month'} >  12 || 0 >= $self->{'_month'}) { 
        $self->{'_month'}  -= 12 if(0 > $self->{'_month'});
        $self->{'_year'}   += int($self->{'_month'} / 12);
        $self->{'_month'}  %= 12;
      }
      # if __use_century && _year > 1000...
    }
  }
  
  # BEGIN legacy `pt` util code
  my $numb; my $rslt; my $temp; 
  #my @dayo = qw(Sun Mon Tue Wed Thu Fri Sat Sha);
  #my @mnth = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
  my @dayo = Time::DayOfWeek::DayNames();   
  my @mnth = Time::DayOfWeek::MonthNames();
  foreach(@dayo) { $_ = substr($_, 0, 3) if(length($_) > 3); }
  foreach(@mnth) { $_ = substr($_, 0, 3) if(length($_) > 3); }
  my %dmap = (); for(my $i=1; $i<=@dayo; $i++) { $dmap{lc($dayo[$i-1])} = $i; }
  my %mmap = (); for(my $i=1; $i<=@mnth; $i++) { $mmap{lc($mnth[$i-1])} = $i; }
  
  sub Pt2Epoch { # converts passed val either to epoch or pt depending
    $numb = shift || return(0); my $ptoe = ""; my $yeer = 0; my @prtz = ();
    if     (0 < length($numb) && length($numb) <=  7) {
      @prtz = split(//, $numb); splice(@prtz,7,($#prtz-7)); # chop extras off!
      for(my $i=0; $i<7; $i++) { unless(defined($prtz[$i])) { $prtz[$i] = 0; } }
      $prtz[1]-- if($prtz[1]);
      $prtz[2]  = 1 unless($prtz[2]);
      @prtz = (b10($prtz[5]), b10($prtz[4]), b10($prtz[3]),
        b10($prtz[2]), b10($prtz[1]), b10($prtz[0]));
  #print "@prtz \n";
      $ptoe = timelocal(@prtz);
    } elsif(7 < length($numb) && length($numb) <= 12) {
      @prtz = localtime($numb);
      @prtz = (b64(int(($prtz[5]-101)*12)+$prtz[4]+1), b64($prtz[3]),
        b64($prtz[2]), b64($prtz[1]), b64($prtz[0]));
      for(my $i = 0; $i < 6; $i++) { $ptoe .= $prtz[$i] if defined($prtz[$i]); }
    }
    return($ptoe);
  }
  
  sub PtCmpPt { # compares two pt's, returns "lt", "eq", "gt", || "ne" if parmerr
  # need year logic to handle exceptions to ordered field progression
    my $numa = shift || return("ne"); $numb = shift || return("ne");
    my $prsl = "eq"; my @prta = split(//, $numa); my @prtb = split(//, $numb);
    for (my $i=0; $i<7; $i++) {
      if($prsl eq "eq") {
        if     (($i < @prtb) && (($i == @prta) || 
                (b10($prta[$i]) < b10($prtb[$i])))) {
          $prsl = "lt";
        } elsif(($i < @prta) && (($i == @prtb) || 
                (b10($prta[$i]) > b10($prtb[$i])))) {
          $prsl = "gt";
        }
      }
    }
  #if ($numa lt $numb) { $prsl = "lt"; } elsif($numa gt $numb) { $prsl = "gt"; } else { $prsl = "eq"; }
    return($prsl);
  }
  
  sub pt {
    my @parm = split(/\s+/, join(' ', @_)); # param
       @parm = split(/\s+/, join(' ', <STDIN>)) if(!@parm && -p STDIN); # pipedin
    my $tout = shift(@parm); my $dayv = shift(@parm); my $dowk; 
    my $colr = 0; my $nwln = 0;
    while(defined($tout) && $tout =~ s/^-+//) {
      if     ($tout =~ /^c/i) {     # escape colored output
        $colr = 1; 
        $colr = 2 if($tout =~ /^cp/); # colored for zshell prompt
      } elsif($tout =~ /^n/i) {     # append newline option
        $nwln = 1;
      } elsif($tout =~ s/^f//i) {   # read input from a file
        if     (length($tout) && -r $tout) { 
          open(INFL, "<$tout");
          @parm = split(/\s+/, join(' ', <INFL>));
          $dayv = shift(@parm);
          close(INFL);
        } elsif(length($dayv) && -r $dayv) { 
          open(INFL, "<$dayv"); $tout = $dayv; $dayv = shift(@parm); 
          @parm = split(/\s+/, join(' ', <INFL>));
          $dayv = shift(@parm);
          close(INFL);
        }
      }
      $tout = $dayv; $dayv = shift(@parm); 
    }
    if (         defined($tout)   && defined($dayv) && 
         exists($dmap{lc($tout)}) && 
        (exists($mmap{lc($dayv)}) || $dayv =~ /^\d\d?$/)) {
      $tout = $dayv; $dayv = shift(@parm); # ignore Day-of-the-Week as first parameter
    }
    my $yerv = shift(@parm); 
    my $horv = shift(@parm); my $minv = shift(@parm); 
    my $secv = shift(@parm); my $frmv = shift(@parm);
    my @lims = ( [ \$horv, 48 ], [ \$minv, 60 ], [ \$secv, 60 ], [ \$frmv, 60 ]);
    if (defined($yerv) && defined($horv) && $yerv =~ /^\d+:\d+(:\d+)?(:\d+)?$/) {
      ($yerv, $horv) = ($horv, $yerv);
    }
    if (defined($dayv) && defined($yerv) &&
      ($dayv =~ /^c(mp)?$/i || $yerv =~ /^c(mp)?$/i)) {
      if ($dayv =~ /^c(mp)?$/i) { $dayv = $yerv; }
      $yerv = "c";
    }
    if(defined($dayv) && defined($yerv) && $dayv =~ /^[+-]$/) {
      $tout .= "$dayv$yerv";
      if(defined($horv)) {
        if   ($horv eq "-e") { $dayv = "-e"; }
        elsif(defined($minv) && $horv =~ /^[+-]$/) {
          $tout .= "$horv$minv";
        }
      }
      if(defined($secv)) {
        if   ($secv eq "-e") { $dayv = "-e"; }
        elsif($secv =~ /^[+-]$/) {
          $temp = shift(@parm);
          if(defined($temp)) { $tout .= "$secv$temp"; }
        }
      }
    }
    my @time = localtime(); @time = @time[0..5]; my @fldz = (); my $year = 0;
    my @stim = (); my $summ = 0; my $oper = 0; my $subs = Time::HiRes::time();
    $subs -= int($subs); $subs = int($subs * 60); unshift(@time, $subs);
    @time = reverse @time;
    if(defined($tout)) {
      $tout = $mmap{lc($tout)} if(exists($mmap{lc($tout)}));
      if($tout =~ /^(\d\d?)([-\/])(\d\d?)\2(\d{1,4})$/) {
        $tout = $1; $dayv = $3; $yerv = $4; # month-day-year
        $yerv =  '0' . $yerv if(length($yerv) == 1);
        $yerv = '20' . $yerv if(length($yerv) == 2);
      }
    }
    if(!defined($tout)) {
      $time[0] -= 100; $time[1]++;
      for(my $i = 0; $i < 7; $i++) { $time[$i] = b64($time[$i]); }
    }
    if((defined($tout) && $tout =~ /^(\w+)([+-].+)$/)) { # add/sub pt
    #print "$tout=";
      $summ = $1; $tout = $2;
      $summ = Pt2Epoch($summ) if (length($summ) <= 7);
      while($tout =~ /^([+-])(\w+)/) {
        $oper = $2; while(length($oper) < 7) { $oper .= "0"; }
        @fldz = split(//, reverse($oper));
        @stim = localtime($summ);
        if ($1 eq "+") {
          $stim[0] += b64($fldz[0]);
          while ($stim[0] > 59) { $stim[1]++; $stim[0] -= 60; }
          $stim[1] += b64($fldz[1]);
          while ($stim[1] > 59) { $stim[2]++; $stim[1] -= 60; }
          $stim[2] += b64($fldz[2]);
          while ($stim[2] > 59) { $stim[3]++; $stim[2] -= 60; }
          $stim[3] += b64($fldz[3]);
          while ($stim[2] > 23) { $stim[3]++; $stim[2] -= 24; }
          $stim[3] += b64($fldz[3]);
          while ($stim[3] > days_in($stim[5], $stim[4])) {
            if ($stim[3] != 29 || $stim[4] != 1 || ($stim[5]%4) != 0) {
              $stim[3] -= days_in($stim[5], $stim[4]); $stim[4]++;
            } elsif ($stim[3] > 29) { # ck leap year
              $stim[3] -= 29; $stim[4]++;
            }
          }
          $stim[4] += (b10($fldz[4])+11)%12 + 1;
          while ($stim[4] > 11) { $stim[4] -= 12; $stim[5]++ if $fldz[4]; }
          $stim[5] += int((b10($fldz[4])-1)/12);
        } else {
          $stim[0] -= b10($fldz[0]);
          while ($stim[0] < 0) { $stim[1]--; $stim[0] += 60; }
          $stim[1] -= b10($fldz[1]);
          while ($stim[1] < 0) { $stim[2]--; $stim[1] += 60; }
          $stim[2] -= b10($fldz[2]);
          while ($stim[2] < 0) { $stim[3]--; $stim[2] += 24; }
          $stim[3] -= b10($fldz[3]);
          while ($stim[3] < 0) {
            if ($stim[4] != 2 || ($stim[5]%4) != 0) {
              $stim[4]--; $stim[3] += days_in($stim[5], $stim[4]);
            } else { # ck leap year
              $stim[4]--; $stim[3] += 29;
            }
          }
          $stim[4] -= (b10($fldz[4])+11)%12 + 1;
          while ($stim[4] < 0) { $stim[4] += 12; $stim[5]-- if $fldz[4]; }
          $stim[5] -= int((b10($fldz[4])-1)/12);
        }
        if (!$stim[3]) { $stim[3]++; } # adding a day to 0-days
        $summ = timelocal(@stim);
        $tout =~ s/^[+-]\w+//;
      }
      if(defined($dayv) && $dayv =~ /^(-e|d)$/) { $rslt = $summ; }
      else                                      { $rslt = Pt2Epoch($summ); }
    #print " ", $summ;
    #print " ", scalar localtime($summ);
    } elsif(defined($tout)) { # turn expanded date parameters into equiv pt
      $tout = $mmap{lc($tout)} if(exists($mmap{lc($tout)}));
      if     ($tout eq "-e" || (defined($dayv) && $dayv eq "-e")) { # cnv pt2ep
    #    ($tout, $dayv) = ($dayv, $tout) if(defined $dayv && $dayv eq "-e");
        if   ($tout eq "pt" || $tout eq "-e") { $rslt = scalar Time::HiRes::time(); }
        elsif(length($tout) > 7)              { $rslt = scalar localtime($tout); }
        else                                  { $rslt = Pt2Epoch($tout); }
      } elsif($tout eq "pt") {
        $dowk = Time::DayOfWeek::Dow($time[0] + 1900, $time[1] + 1, $time[2]);
        $rslt = sprintf("%s %s %2s %02d:%02d:%02d:%02d %4d", 
                    $dowk, $mnth[($time[1] % @mnth)], $time[2], $time[3], 
                    $time[4], $time[5], $time[6], $time[0] + 1900);
      } elsif(defined($dayv) && length($dayv) && length($tout) &&
        defined($yerv) && $yerv eq "c") {                    # compare two pt's
        $rslt = PtCmpPt($tout, $dayv);
      } else {                                               # normal pt decoding
        @time = split(//, $tout); @time = @time[0..6]; # chop extras off!
        for(my $i=0; $i<7; $i++) { 
          if(defined($time[$i])) { $time[$i] = b10($time[$i]); } 
          else                   { $time[$i] = 0; } 
        }
  #  0) Each 12 added to the Month adds  64 to the Year.
  #  1)      24 added to the Hour  adds 320 to the Year.
  #  2)      31 added to the Day   makes the year negative just before adding 2k
        $time[1]-- if($time[1]);     # 0-base month
        $time[2]++ unless($time[2]); # 1-base day
        $time[1] %= 60; # 5 month blocks go 0-59  (0-11,12-23,24-35,36-47,48-59)
        $time[2] = 1 if($time[2] > 62); # day  blocks go 1..62  (1..31, 32..62)
        $time[3] %= 48;                 # hour blocks go 0..47  (0..23, 24..47)
        $time[4] %= 60; $time[5] %= 60; $time[6] %= 60; # min,sec,60th all 0..59
        while($time[1] > 11) { $time[0] +=  64; $time[1] -= 12; }
        if   ($time[3] > 23) { $time[0] += 320; $time[3] -= 24; }
        if   ($time[2] > 31) { $time[0] *=  -1; $time[2] -= 31; }
  #print "tout:$tout\ntime:@time\n";
        $time[0] += 100;
        $dowk = Time::DayOfWeek::Dow($time[0] + 1900, $time[1] + 1, $time[2]);
        $rslt = sprintf("%s %s %2s %02d:%02d:%02d:%02d %4d", 
                    $dowk, $mnth[($time[1] % @mnth)], $time[2], $time[3], 
                    $time[4], $time[5], $time[6], $time[0] + 1900);
      }
    } else {                                                 # normal pt encoding
      if($colr) {
        if($colr == 2) {
          $rslt = "%{\e[1;31m%}$time[0]" . 
                  "%{\e[0;33m%}$time[1]" . 
                  "%{\e[1;33m%}$time[2]" . 
                  "%{\e[32m%}$time[3]"   . 
                  "%{\e[36m%}$time[4]"   . 
                  "%{\e[34m%}$time[5]"   . 
                  "%{\e[35m%}$time[6]";
        } else {
          $rslt = "\e[1;31m$time[0]" . 
                  "\e[0;33m$time[1]" . 
                  "\e[1;33m$time[2]" . 
                  "\e[32m$time[3]"   . 
                  "\e[36m$time[4]"   . 
                  "\e[34m$time[5]"   . 
                  "\e[35m$time[6]";
        }
      } else {
        $rslt = join('', @time);
      }
    #$temp = join('', @time); print "\n", `cnv $temp 64 128`, "\n", `cnv $temp 64 10`;
    } # print "\n"; # hmmm...
    $rslt .= "\n" if($nwln);
    return($rslt);
  }
  # END legacy `pt` util code
  
  sub ptcc { # Generic PipTime Curses::Simp Color Code strings as class method
    my $frmt = shift || 0; my $ptst;
    if     ($frmt =~ /^-*f/i) {
      $ptst = '!YYY OOO YY GGWCCWUUWPP RRRR';
      #`pt pt`->Wed Jul 16 00:03:31:30 2003
    } elsif($frmt =~ /^-*k/i) {
      $ptst = '!ROYuX3GCUP'; # same as below but with 'hms' in blue bkgrnd
    } else {
      $ptst = '!ROYGCUP';    #'.bROYGCUP.';
      # `pt`->  YMDhmsf          YMDhmsf   
    }
    return($ptst); 
  }
  
  # returns a PT object's expanded string form
  sub expand {
    my $self = shift; 
    return(sprintf("%3s %3s %2d %02d:%02d:%02d:%02d %4d", 
  #    Time::DayOfWeek::Dow($self->YMD), 
                           $self->Dow(),
                     $mnth[$self->month() - 1],
                           $self->day(),
                           $self->hour(),
                           $self->minute(),
                           $self->second(),
                           $self->frame(),
                           $self->year()));
  }
  
  # adds color codes corresponding to each field according to ColorTYPe
  #   (/^s/i) ? Curses::Simp color codes
  # : (/^h/i) ? HTML links && font color tag delimiters
  # : (/^4/i) ? 4NT verbose color codes
  # : ANSI color escapes (/^z/i) ? wrapped in zsh delimiters;
  sub _color_fields {
    my $self = shift;
    my $fstr = shift || ' ' x 10; $fstr =~ s/0+$// if(length($fstr) <= 7);
    my $ctyp = shift || 'ANSI';
    my @clrz = (); my $coun = 0; my $rstr = '';
    if     ($ctyp =~ /^s/i) { # simp color codes
      @clrz = @{$self->_field_colors('simp')};
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun++]; }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun++)]; }
      }
    } elsif($ctyp =~ /^h/i) { # HTML link && font color tag delimiters
      @clrz = @{$self->_field_colors('html')};
      $_    = '<font color="#' . $_ . '">' foreach(@clrz);
      $rstr = '<a href="http://Ax9.Org/pt?' . $fstr . '">';
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1) . '</font>'; }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun)] . substr($fstr, $coun++, 1) . '</font>'; }
      }
      $rstr .= '</a>';
    } elsif($ctyp =~ /^4/i) { # 4NT prompt needs verbose color codes
      @clrz = @{$self->_field_colors('4nt')};
      for(my $i=0; $i<@clrz; $i++) {
        $clrz[$i] = ' & color ' . $clrz[$i] . ' & echos ';
      }
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1); }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun)] . substr($fstr, $coun++, 1); }
      }
    } else { # ANSI escapes
      @clrz = @{$self->_field_colors('ansi')};
      if($ctyp =~ /^z/i) { # zsh prompt needs delimited %{ ANSI %}
        for(my $i=0; $i<@clrz; $i++) { $clrz[$i] = '%{' . $clrz[$i] . '%}'; }
      }
      if(length($fstr) > 7) {
        while(length($fstr) > $coun) { $rstr .= $clrz[$coun] . substr($fstr, $coun++, 1); }
      } else {
        while(length($fstr) > $coun) { $rstr .= $clrz[(1 + $coun)] . substr($fstr, $coun++, 1); }
      }
    }
    return($rstr);
  }
  
  # Time::PT object constructor as class method or copy as object method.
  # First param can be ref to copy.  Not including optional ref from 
  #   copy, default is no params to create a new empty PT object.
  # If params are supplied, they must be a single key && a single value.
  # The key must be one of the following 3 types of constructor 
  #   initialization mechanisms:
  #    -1) <packedB64InitStringImplies'str'>(eg. '3C79jo0')
  #     0) 'str'  => <packedB64InitString>  (eg. 'str'  => '0123456789')
  #     1) 'list' => <arrayRef>             (eg. 'list' => [0, 1, 2..9])
  #     2) 'hash' => <hashRef>              (eg. 'hash' => {'jink' => 8})
  sub new { 
    my ($nvkr, $ityp, $idat) = @_; 
    my $nobj = ref($nvkr);
    my $clas = $ityp;
    $clas = $nobj || $nvkr if(!defined($ityp) || $ityp !~ /::/);
    my $self = Time::Fields->new($clas);
    my $rgxs; my $mont; my @attz = $self->_attribute_names();
  #       timelocal($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst)
    my @ltim = localtime(); my $subs = Time::HiRes::time(); $subs -= int($subs); 
    $self->{'_year'}   = $ltim[5] + 1900;
    $self->{'_month'}  = $ltim[4] + 1;
    $self->{'_day'}    = $ltim[3];
    $self->{'_hour'}   = $ltim[2];
    $self->{'_minute'} = $ltim[1];
    $self->{'_second'} = $ltim[0];
    $self->{'_frame'}  = int($subs * $self->{'__fps'});
    #$subs *= $self->{'__fps'}; $subs -= int($subs);
    #$self->{'_jink'}   = int($subs * $self->{'__jpf'});
    $self->{'__time_separator'} = ':';
    $self->{'__date_separator'} = '-';
    foreach my $attr ( @attz ) { 
  #    $self->{$attr} = $self->_default_value($attr); # init defaults
      $self->{$attr} = $nvkr->{$attr} if($nobj);     #  && copy if supposed to
    }
    if(defined($ityp) && $ityp !~ /::/) { # there were initialization params
      foreach my $attr ( @attz ) { 
        $self->{$attr} = $self->_default_value($attr); # init defaults
      }
      ($ityp, $idat) = ('str', $ityp) unless(defined($idat));
      if($ityp =~ /^verbose$/i) { # handle 'verbose' differently
        # verbose string param is expanded date &&/or time text
        $rgxs = '^\\s*((' . join('|', @dayo) . ')\\S*)?\\s*(' . 
                            join('|', @mnth) . ')\\S*\\s*(\\d+)' .
                 '\\s+(\\d+(\D+(\\d+)){0,4})\\s+(\d+)\\s*$';
        if($idat =~ /$rgxs/i) { 
  #print "idat:$idat\nrgxs:$rgxs\nDow?$2 Mon$3 dy$4 hr:mn?:sc?:fr?:jn?$5 YEAR!\n"; 
          $mont                = $3;
          $self->{'_day'}      = $4;
          ($self->{'_hour'}  , 
           $self->{'_minute'}, 
           $self->{'_second'}, 
           $self->{'_frame'} , 
           $self->{'_jink'}  ) = split(/\D+/, $5);
          $self->{'_year'}     = $8;
  #print "M:$mont D:$self->{'_day'} h:($self->{'_hour'} m:$self->{'_minute'} s:$self->{'_second'} f:$self->{'_frame'} j:($self->{'_jink'} Y:$self->{'_year'}\n";
        } else {
          $rgxs = '^\\s*((' . join('|', @dayo) . ')\\S*)?\\s*(' . 
                              join('|', @mnth) . ')\\S*\\s*(' .
                  '\\d+)\\s*,?\\s*(\\d+)\\s*$';
          if($idat =~ /$rgxs/i) { 
  #print "Dow?$2 " if(defined($2)); print "Mon$3 dy$4 YEAR$5!\n"; 
            $mont            = $3;
            $self->{'_day'}  = $4;
            $self->{'_year'} = $5;
          } else {
            $rgxs = '^\\s*(\\d+(\D+(\\d+)){0,4})\\s*$';
            if($idat =~ /$rgxs/i) {
  print "hr:mn?:sc?:fr?:jn?!\n"; 
  # 2do: continue testing && assigning all acceptable verbose formats
            }
          }
        }
        if(defined($mont)) { # convert named month to proper index number
          for(my $i = 0; $i < @mnth; $i++) { # find which month name
            if(lc($mont) eq lc($mnth[$i])) { # $mont =~ /^$mnth[$i]/i) {
              $self->{'_month'} = ($i + 1); # ($i + 1) for 1-based month field
            }
          }
        }
      } elsif($ityp =~ /^s/i && length($idat) <= 9) { # handle small 'str' differently
        # small str param grows right from year field
        my $ilen = length($idat);
        for(my $i = 1; $i <= $ilen; $i++) {
          if($idat =~ s/^(.)//) {
            $self->{$attz[$i]} = b10($1); # break down str
          }
        }
        $self->{'_year'} += 2000;
      } else {
        foreach my $attr ( @attz ) {
          if     ($ityp =~ /^s/i) {    # 'str'
            $self->{$attr} = b10($1) if($idat =~ s/^(.)//);  # break down string
          } elsif($ityp =~ /^[la]/i) { # 'list' or 'array'
            $self->{$attr} = shift( @{$idat} ) if(@{$idat}); # shift list vals
          } elsif($ityp =~ /^h/i) {    # 'hash'
            # do some searching to find hash key that matches
            foreach(keys(%{$idat})) {
              if($attr =~ /$_/) {
                $self->{$attr} = $idat->{$_};
                delete($idat->{$_});
              }
            }
          } else { # undetected init type
            croak "!*EROR*! PT::new initialization type: $ityp did not match 'str', 'list', or 'hash'!\n";
          }
        }
      }
    }
    foreach my $attr ( @attz ) { # init defaults for any undefined fields
      $self->{$attr} = $self->_default_value($attr) unless(defined($self->{$attr})); 
    }
  # Handle Year shifts
      $self->{'_year'} -= 2000;
  #   0) Each 12 added to the Month adds  64 to the Year.
  #   1)      24 added to the Hour  adds 320 to the Year.
  #   2)      31 added to the Day   makes the year negative just before adding 2k
    my $mdec = 0; $mdec = 1 if($self->{'_month'}); 
    $self->{'_month'}-- if($mdec); # 0-base month
    my $dinc = 0; $dinc = 1 unless($self->{'_day'}); 
    $self->{'_day'}++   if($dinc); # 1-base day
    # 5 month blocks go 0..59  (0..11,12..23,24..35,36..47,48..59)
    $self->{'_month'} %= 60; 
    #   day   blocks go 1..62  (1..31, 32..62)
    $self->{'_day'}    = 1 if($self->{'_day'} > 62); 
    #   hour  blocks go 0..47  (0..23, 24..47)
    $self->{'_hour'}  %= 48;  
    # min,sec,frm,jnk all 0..59
    $self->{'_minute'} %= 60; $self->{'_second'} %= 60; 
    $self->{'_frame'}  %= 60; $self->{'_jink'}   %= 60; 
    while($self->{'_month'} > 11) { 
      $self->{'_year'} +=  64; $self->{'_month'} -= 12; 
    }
    if   ($self->{'_hour'}  > 23) { 
      $self->{'_year'} += 320; $self->{'_hour'}  -= 24; 
    }
    if   ($self->{'_day'}   > 31) { 
      $self->{'_year'} *=  -1; $self->{'_day'}   -= 31; 
    }
    $self->{'_day'}--   if($dinc); # 0-base day   again only if inc'd above
    $self->{'_month'}++ if($mdec); # 1-base month again only if dec'd above
    $self->{'_year'} += 2000;
    return($self);
  }
  
  sub subsecond { return(frame(@_)); }
  sub _mon { # 0-based month
    my ($self, $nwvl) = @_;
    $self->{'_month'} = ($nwvl + 1) if(@_ > 1);
    return($self->{'_month'} - 1);
  }
  sub fullmonth { # full month string
    my ($self, $nwvl) = @_; my $mtch; my $mret; 
    my @mnmz = Time::DayOfWeek::MonthNames();
    if(@_ > 1) {
      for($mtch=0; $mtch<@mnmz; $mtch++) {
        if($mnmz[$mtch] =~ /^$nwvl/i) {
          $self->{'_month'} = $mtch + 1; last;
        }
      }
    }
    $mret = $mnmz[(($self->{'_month'} - 1) % 12)];
    return($mret);
  }
  sub monname { # abbreviated month string
    my $monr = $_[0]->fullmonth();
    if   (@_ > 2) { $monr = $_[ $_[0]->M ];          }
    elsif(@_ > 1) { $monr = $_[0]->fullmonth($_[1]); }
    $monr = substr($monr, 0, 3) if(length($monr) > 3);
    return($monr);
  }
  sub _year { # 1900-based year
    my ($self, $nwvl) = @_;
    $self->{'_year'} = ($nwvl + 1900) if(@_ > 1);
    return($self->{'_year'} - 1900);
  }
  sub yy { # 2-digit year
    my ($self, $nwvl) = @_; my $yret;
    if(@_ > 1) {
      ($nwvl >= 70) ? $self->{'_year'} = '19' . $nwvl :
                      $self->{'_year'} = '20' . $nwvl;
    }
    $yret = sprintf("%04d", $self->{'_year'});
    return(substr($self->{'_year'}, 2, 2));
  }
  sub dow { # index of day of week
    my ($self, $nwvl) = @_;
    return(Time::DayOfWeek::DoW($self->YMD));
  }
  sub Dow { # abbrev. day name
    my ($self, $nwvl) = @_;
    return(Time::DayOfWeek::Dow($self->YMD));
  }
  sub DayOfWeek { # full day name
    my ($self, $nwvl) = @_;
    return(Time::DayOfWeek::DayOfWeek($self->YMD));
  }
  *day_of_week = \&dow;
  *_wday       = \&dow;
  sub wday     { return(dow(@_) + 1);  }
  sub wdayname {
    return($_[ $_[0]->wday ]) if(@_ > 2);
    return(Dow(@_));
  }
  #*day         = \&Dow; # let day be day-of-month rather than Time::Piece wk-day
  *fullday     = \&DayOfWeek;
  sub   yday      { # day of year
    my ($self, $nwvl) = @_; my $summ = 0;
    if(@_ > 1) {
      for(my $m=1; $m<12; $m++) {
        if(($summ + days_in($self->{'_year'}, $m)) > $nwvl) {
          $self->{'_month'} = $m;
          $self->{'_day'}   = $nwvl - $summ;
          last;
        } else {
          $summ += days_in($self->{'_year'}, $m);
        }
      }
      $summ = $nwvl;
    } else {
      for(my $m=1; $m<$self->{'_month'}; $m++) {
        $summ += days_in($self->{'_year'}, $m);
      }
      $summ += ($self->{'_day'} - 1);
    }
  # following compares my yday calculation to localtime's
  #my @ltdt = localtime(timelocal($self->smhD, $self->_mon, $self->Y));
  #print "!EROR!summ:$summ != ltdt:" . $ltdt[-2] . "\n" if($summ != $ltdt[-2]);
  #print join('', $self->smhD) . $self->_mon . ($self->Y - 1900) . "\n" .  join('', @ltdt) . "\n";
    return($summ);
  }
  *day_of_year = \&yday;
  # isdst should be computed by formula when I figure out how so that it 
  #   won't be restricted by UTC range that localtime expects.
  sub isdst { # Is Daylight Savings Time?
    my ($self, $nwvl) = @_; # need 0-based month as timelocal() param
    my @ltdt = localtime(timelocal($self->smhD, $self->_mon, $self->Y));
    return($ltdt[-1]); 
  }
  *daylight_savings = \&isdst;
  sub    time { return(    hmsf(  @_)); }
  sub alltime { return(    hmsfjz(@_)); }
  sub    date { return( YMD(      @_)); }
  sub alldate { return(CYMD(      @_)); }
  sub pt7     { return( YMDhmsf(  @_)); }
  sub all     { return(CYMDhmsfjz(@_)); }
  *dt = \&all;
  sub datetime { #  2000-02-29T12:34:56            (ISO 8601)
    return(sprintf("%04d-%02d-%02dT%02d:%02d:%02d", $_[0]->YMDhms())); 
  }
  *cdate    = \&expand;
  *compress = \&stringify;
  # Add these to pod once imp'd
  #    $t->epoch               # floating point seconds since the epoch
  #    $t->tzoffset            # timezone offset in a Time::Seconds object
  #
  #    $t->julian_day          # number of days since Julian period began
  #    $t->mjd                 # modified Julian date (JD-2400000.5 days)
  #
  #    $t->week                # week number (ISO 8601)
  sub epoch { # floating point seconds since the epoch
    return(0);
  }
  sub tzoffset { # timezone offset in a Time::Seconds object
    return(0);
  }
  sub julian_day { # number of days since Julian period began
    return(0);
  }
  sub mjd { # modified Julian date (JD-2400000.5 days)
    return(0);
  }
  sub week { # week number (ISO 8601)
    return(0);
  }
  sub is_leap_year { # true if it its
    return(0);
  }
  sub month_last_day { # 28-31
    return(days_in($_[0]->YM));
  }
  sub time_separator { # set the default separator (default ":")
    $_[0]->{'__time_separator'} = $_[1] if(@_ > 1);
    return($_[0]->{'__time_separator'});
  }
  sub date_separator { # set the default separator (default "-")
    $_[0]->{'__date_separator'} = $_[1] if(@_ > 1);
    return($_[0]->{'__date_separator'});
  }
  sub day_list { # set the default weekdays
    my $self = shift;
    return(Time::DayOfWeek::DayNames(@_));
  }
  sub mon_list { # set the default months
    my $self = shift;
    return(Time::DayOfWeek::MonthNames(@_));
  }
  
  #sub AUTOLOAD { # methods (created as necessary)
  #  no strict 'refs';
  #  my ($self, $nwvl) = @_;
  #
  #  if     ($AUTOLOAD =~ /.*::[-_]?([CYMODhmisfjz])(.)?/i) { 
  #    my ($atl1, $atl2) = ($1, $2); my $atnm;
  #    my @mnmz = Time::DayOfWeek::MonthNames();
  #    $atl1 = 'O' if($atl1 eq 'm' && defined($atl2) && lc($atl2) eq 'o');
  #    $atl1 = 'i' if($atl1 eq 'M' && defined($atl2) && lc($atl2) eq 'i');
  #    $atl1 = 'O' if($atl1 eq 'M');
  #    $atl1 = 'i' if($atl1 eq 'm');
  #    $atl1 = 'O' if($AUTOLOAD =~ /.*::fullmon/i);
  #    foreach my $attr ($self->_attribute_names()){
  #      my $mtch = $self->_attribute_match($attr);
  #      $atnm = $attr if(defined($mtch) && $atl1 =~ /$mtch/i);
  #    }
  #    if($atl1 eq 'O') {
  #      if($AUTOLOAD =~ /.*::_/) { # 0-based month
  #        *{$AUTOLOAD} = sub { $_[0]->{$atnm} = ($_[1] + 1) if(@_ > 1); return($_[0]->{$atnm} - 1); };
  #        $self->{$atnm} = ($nwvl + 1) if(@_ > 1);
  #        return($self->{$atnm} - 1);
  #      } elsif($AUTOLOAD =~ /.*::(full)?mon(th|n)/i) { # abbrev. Mon Name
  #        if(defined $1) { # store fullmon to do the matching
  #          *{$AUTOLOAD} = sub { 
  #            my $mtch;
  #            if(@_ > 1) {
  #              foreach($mtch=0; $mtch<@mnmz; $mtch++) {
  #                if($mnmz[$mtch] =~ /^$_[1]/i) { 
  #                  $_[0]->{$atnm} = $mtch + 1; last; 
  #                }
  #              }
  #            }
  #            return($mnmz[(($_[0]->{$atnm} - 1) % 12)]);
  #          };
  #        } else { # store mon(th|n) as a wrapper that truncs fullmon
  #          *{$AUTOLOAD} = sub { 
  #            my $monr = $_[0]->fullmonth();
  #               $monr = $_[0]->fullmonth($_[1]) if(@_ > 1);
  #            $monr = substr($monr, 0, 3) if(length($monr) > 3);
  #            return($monr);
  #          };
  #        }
  #        my $mtch; my $mret;
  #        if(@_ > 1) {
  #          for($mtch=0; $mtch<@mnmz; $mtch++) {
  #            if($mnmz[$mtch] =~ /^$nwvl/i) {
  #              $self->{$atnm} = $mtch + 1; last;
  #            }
  #          }
  #        }
  #        $mret = $mnmz[(($self->{$atnm} - 1) % 12)];
  #        if($AUTOLOAD !~ /.*::full/i && length($mret) > 3) {
  #          $mret = substr($mret, 0, 3);
  #        }
  #        return($mret);
  #      }
  #    }
  #  # normal set_/get_ methods
  #
  #  if     ($AUTOLOAD =~ /.*::[sg]et(_\w+)/i) {
  #    my $atnm = lc($1);
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1);
  #    return($self->{$atnm});
  #  # use_??? to set/get field filters
  #  } elsif($AUTOLOAD =~ /.*::(use_\w+)/i) {
  #    my $atnm = '__' . lc($1);
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1);
  #    return($self->{$atnm});
  #  # Alias methods which must be detected before sweeps
  #  } elsif($AUTOLOAD =~ /.*::time$/i) { 
  #    *{$AUTOLOAD} = sub { return($self->hms()); };
  #    return($self->hms());
  #  } elsif($AUTOLOAD =~ /.*::dt$/i) { 
  #    *{$AUTOLOAD} = sub { return($self->CYMDhmsfjz()); };
  #    return($self->CYMDhmsfjz());
  #  } elsif($AUTOLOAD =~ /.*::mday$/i) { my $atnm = '_day';
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1); return($self->{$atnm});
  #  # all joint field methods (eg. YMD(), hms(), foo(), etc.
  #  } elsif($AUTOLOAD =~ /.*::([CYMODhmisfjz][CYMODhmisfjz]+)$/i) { 
  #    my @fldl = split(//, $1); 
  #    my ($self, @nval) = @_; my @rval = (); my $atnm = ''; my $rgex;
  #    # handle Month / minute exceptions
  #    for(my $i=0; $i<$#fldl; $i++) {
  #      $fldl[$i + 1] = 'O' if($fldl[$i] =~ /[yd]/i && $fldl[$i + 1] eq 'm');
  #      $fldl[$i    ] = 'O' if($fldl[$i] eq 'm'     && $fldl[$i + 1] =~ /[yd]/i);$      $fldl[$i    ] = 'O' if($fldl[$i] eq 'M');
  #      $fldl[$i    ] = 'i' if($fldl[$i] eq 'm');
  #    }
  #    *{$AUTOLOAD} = sub { 
  #      my ($self, @nval) = @_; my @rval = (); 
  #      for(my $i=0; $i<@fldl; $i++) {
  #        foreach my $attr ($self->_attribute_names()){
  #          my $mtch = $self->_attribute_match($attr);
  #          if(defined($mtch) && $fldl[$i] =~ /^$mtch/i) {
  #            $self->{$attr} = $nval[$i] if($i < @nval);
  #            push(@rval, $self->{$attr});
  #          }
  #        }
  #      }
  #      return(@rval);
  #    };
  #    for(my $i=0; $i<@fldl; $i++) {
  #      foreach my $attr ($self->_attribute_names()){
  #        my $mtch = $self->_attribute_match($attr);
  #        if(defined($mtch) && $fldl[$i] =~ /$mtch/i) {
  #          $self->{$attr} = $nval[$i] if($i < @nval);
  #          push(@rval, $self->{$attr});
  #        }
  #      }
  #    }
  #    return(@rval);
  #  # sweeping matches to handle partial keys
  #  } elsif($AUTOLOAD =~ /.*::[-_]?([CYMODhmisfjz])(.)?/i) { 
  #    my ($atl1, $atl2) = ($1, $2); my $atnm;
  #    $atl1 = 'O' if($atl1 eq 'm' && defined($atl2) && lc($atl2) eq 'o');
  #    $atl1 = 'i' if($atl1 eq 'M' && defined($atl2) && lc($atl2) eq 'i');
  #    $atl1 = 'O' if($atl1 eq 'M');
  #    $atl1 = 'i' if($atl1 eq 'm');
  #    foreach my $attr ($self->_attribute_names()) {
  #      my $mtch = $self->_attribute_match($attr);
  #      $atnm = $attr if(defined($mtch) && $atl1 =~ /$mtch/i);
  #    }
  #    *{$AUTOLOAD} = sub { $_[0]->{$atnm} = $_[1] if(@_ > 1); return($_[0]->{$atnm}); };
  #    $self->{$atnm} = $nwvl if(@_ > 1);
  #    return($self->{$atnm});
  #  } else {
  #    my $fnam = $AUTOLOAD;
  #    $fnam =~ s/Time::PT::/Time::Fields::/;
  #    return(&$fnam);
  #    croak "No such method: $AUTOLOAD\n";
  #  }
  #}
  
  sub DESTROY { } # do nothing but define in case && to calm warning in test.pl
  
  127;
TIME_PT

$fatpacked{"Time/ParseDate.pm"} = <<'TIME_PARSEDATE';
  
  package Time::ParseDate;
  
  require 5.000;
  
  use Carp;
  use Time::Timezone;
  use Time::JulianDay;
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(parsedate);
  @EXPORT_OK = qw(pd_raw %mtable %umult %wdays);
  
  use strict;
  #use diagnostics;
  
  # constants
  use vars qw(%mtable %umult %wdays $VERSION);
  
  $VERSION = 2011.0517;
  
  # globals
  use vars qw($debug); 
  
  # dynamically-scoped
  use vars qw($parse);
  
  my %mtable;
  my %umult;
  my %wdays;
  my $y2k;
  
  CONFIG:	{
  
  	%mtable = qw(
  		Jan 1	Jan. 1	January 1
  		Feb 2	Feb. 2	February 2
  		Mar 3	Mar. 3	March 3
  		Apr 4	Apr. 4	April 4
  		May 5 
  		Jun 6	Jun. 6	June 6 
  		Jul 7	Jul. 7	July 7 
  		Aug 8	Aug. 8	August 8 
  		Sep 9	Sep. 9	September 9 
  		Oct 10	Oct. 10	October 10 
  		Nov 11	Nov. 11	November 11 
  		Dec 12	Dec. 12	December 12 );
  	%umult = qw(
  		sec 1 second 1
  		min 60 minute 60
  		hour 3600
  		day 86400
  		week 604800 
  		fortnight 1209600);
  	%wdays = qw(
  		sun 0 sunday 0
  		mon 1 monday 1
  		tue 2 tuesday 2
  		wed 3 wednesday 3
  		thu 4 thursday 4
  		fri 5 friday 5
  		sat 6 saturday 6
  		);
  
  	$y2k = 946684800; # turn of the century
  }
  
  sub parsedate
  {
  	my ($t, %options) = @_;
  
  	my ($y, $m, $d);	# year, month - 1..12, day
  	my ($H, $M, $S);	# hour, minute, second
  	my $tz;		 	# timezone
  	my $tzo;		# timezone offset
  	my ($rd, $rs);		# relative days, relative seconds
  
  	my $rel; 		# time&|date is relative
  
  	my $isspec;
  	my $now = defined($options{NOW}) ? $options{NOW} : time;
  	my $passes = 0;
  	my $uk = defined($options{UK}) ? $options{UK} : 0;
  
  	local $parse = '';  # will be dynamically scoped.
  
  	if ($t =~ s#^   ([ \d]\d) 
  			/ (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)
  			/ (\d\d\d\d)
  			: (\d\d)
  			: (\d\d)
  			: (\d\d)
  			(?:
  			 [ ]
  			 ([-+] \d\d\d\d)
  			  (?: \("?(?:(?:[A-Z]{1,4}[TCW56])|IDLE)\))?
  			 )?
  			##xi) { #"emacs
  		# [ \d]/Mon/yyyy:hh:mm:ss [-+]\d\d\d\d
  		# This is the format for www server logging.
  
  		($d, $m, $y, $H, $M, $S, $tzo) = ($1, $mtable{"\u\L$2"}, $3, $4, $5, $6, $7 ? &mkoff($7) : ($tzo || undef));
  		$parse .= " ".__LINE__ if $debug;
  	} elsif ($t =~ s#^(\d\d)/(\d\d)/(\d\d)\.(\d\d)\:(\d\d)(\s+|$)##) {
  		# yy/mm/dd.hh:mm
  		# I support this format because it's used by wbak/rbak
  		# on Apollo Domain OS.  Silly, but historical.
  
  		($y, $m, $d, $H, $M, $S) = ($1, $2, $3, $4, $5, 0);
  		$parse .= " ".__LINE__ if $debug;
  	} else {
  		while(1) {
  			if (! defined $m and ! defined $rd and ! defined $y
  				and ! ($passes == 0 and $options{'TIMEFIRST'}))
  			{
  				# no month defined.
  				if (&parse_date_only(\$t, \$y, \$m, \$d, $uk)) {
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $H and ! defined $rs) {
  				if (&parse_time_only(\$t, \$H, \$M, \$S, 
  					\$tz, %options)) 
  				{
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			next if $passes == 0 and $options{'TIMEFIRST'};
  			if (! defined $y) {
  				if (&parse_year_only(\$t, \$y, $now, %options)) {
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $tz and ! defined $tzo and ! defined $rs 
  				and (defined $m or defined $H)) 
  			{
  				if (&parse_tz_only(\$t, \$tz, \$tzo)) {
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $H and ! defined $rs) {
  				if (&parse_time_offset(\$t, \$rs, %options)) {
  					$rel = 1;
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (! defined $m and ! defined $rd and ! defined $y) {
  				if (&parse_date_offset(\$t, $now, \$y, 
  					\$m, \$d, \$rd, \$rs, %options)) 
  				{
  					$rel = 1;
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			if (defined $M or defined $rd) {
  				if ($t =~ s/^\s*(?:at|\@|\+)\s*(\s+|$)//x) {
  					$rel = 1;
  					$parse .= " ".__LINE__ if $debug;
  					next;
  				}
  			}
  			last;
  		} continue {
  			$passes++;
  			&debug_display($tz, $tzo, $H, $M, $S, $m, $d, $y, $rs, $rd, $rel, $passes, $parse, $t) if $debug;
  
  		}
  
  		if ($passes == 0) {
  			print "nothing matched\n" if $debug;
  			return (undef, "no match on time/date") 
  				if wantarray();
  			return undef;
  		}
  	}
  
  	&debug_display($tz, $tzo, $H, $M, $S, $m, $d, $y, $rs, $rd, $rel, $passes, $parse, $t) if $debug;
  
  	$t =~ s/^\s+//;
  
  	if ($t ne '') {
  		# we didn't manage to eat the string
  		print "NOT WHOLE\n" if $debug;
  		if ($options{WHOLE}) {
  			return (undef, "characters left over after parse")
  				if wantarray();
  			return undef 
  		}
  	}
  
  	# define a date if there isn't one already
  
  	if (! defined $y and ! defined $m and ! defined $rd) {
  		print "no date defined, trying to find one." if $debug;
  		if (defined $rs or defined $H) {
  			# we do have a time.
  			if ($options{DATE_REQUIRED}) {
  				return (undef, "no date specified")
  					if wantarray();
  				return undef;
  			}
  			if (defined $rs) {
  				print "simple offset: $rs\n" if $debug;
  				my $rv = $now + $rs;
  				return ($rv, $t) if wantarray();
  				return $rv;
  			}
  			$rd = 0;
  		} else {
  			print "no time either!\n" if $debug;
  			return (undef, "no time specified")
  				if wantarray();
  			return undef;
  		}
  	}
  
  	if ($options{TIME_REQUIRED} && ! defined($rs) 
  		&& ! defined($H) && ! defined($rd))
  	{
  		return (undef, "no time found")
  			if wantarray();
  		return undef;
  	}
  
  	my $secs;
  	my $jd;
  
  	if (defined $rd) {
  		if (defined $rs || ! (defined($H) || defined($M) || defined($S))) {
  			print "fully relative\n" if $debug;
  			my ($j, $in, $it);
  			my $definedrs = defined($rs) ? $rs : 0;
  			my ($isdst_now, $isdst_then);
  			my $r = $now + $rd * 86400 + $definedrs;
  			#
  			# It's possible that there was a timezone shift 
  			# during the time specified.  If so, keep the
  			# hours the "same".
  			#
  			$isdst_now = (localtime($r))[8];
  			$isdst_then = (localtime($now))[8];
  			if (($isdst_now == $isdst_then) || $options{GMT})
  			{
  				return ($r, $t) if wantarray();
  				return $r 
  			}
  				
  			print "localtime changed DST during time period!\n" if $debug;
  		}
  
  		print "relative date\n" if $debug;
  		$jd = $options{GMT}
  			? gm_julian_day($now)
  			: local_julian_day($now);
  		print "jd($now) = $jd\n" if $debug;
  		$jd += $rd;
  	} else {
  		unless (defined $y) {
  			if ($options{PREFER_PAST}) {
  				my ($day, $mon011);
  				($day, $mon011, $y) = (&righttime($now))[3,4,5];
  
  				print "calc year -past $day-$d $mon011-$m $y\n" if $debug;
  				$y -= 1 if ($mon011+1 < $m) || 
  					(($mon011+1 == $m) && ($day < $d));
  			} elsif ($options{PREFER_FUTURE}) {
  				print "calc year -future\n" if $debug;
  				my ($day, $mon011);
  				($day, $mon011, $y) = (&righttime($now))[3,4,5];
  				$y += 1 if ($mon011 >= $m) || 
  					(($mon011+1 == $m) && ($day > $d));
  			} else {
  				print "calc year -this\n" if $debug;
  				$y = (localtime($now))[5];
  			}
  			$y += 1900;
  		}
  
  		$y = expand_two_digit_year($y, $now, %options)
  			if $y < 100;
  
  		if ($options{VALIDATE}) {
  			require Time::DaysInMonth;
  			my $dim = Time::DaysInMonth::days_in($y, $m);
  			if ($y < 1000 or $m < 1 or $d < 1 
  				or $y > 9999 or $m > 12 or $d > $dim)
  			{
  				return (undef, "illegal YMD: $y, $m, $d")
  					if wantarray();
  				return undef;
  			}
  		}
  		$jd = julian_day($y, $m, $d);
  		print "jd($y, $m, $d) = $jd\n" if $debug;
  	}
  
  	# put time into HMS
  
  	if (! defined($H)) {
  		if (defined($rd) || defined($rs)) {
  			($S, $M, $H) = &righttime($now, %options);
  			print "HMS set to $H $M $S\n" if $debug;
  		} 
  	}
  
  	my $carry;
  
  	print "before ", (defined($rs) ? "$rs" : ""),
  		    " $jd $H $M $S\n" 
  		if $debug;
  	#
  	# add in relative seconds.  Do it this way because we want to
  	# preserve the localtime across DST changes.
  	#
  
  	$S = 0 unless $S; # -w
  	$M = 0 unless $M; # -w
  	$H = 0 unless $H; # -w
  
  	if ($options{VALIDATE} and
  		($S < 0 or $M < 0 or $H < 0 or $S > 59 or $M > 59 or $H > 23)) 
  	{
  		return (undef, "illegal HMS: $H, $M, $S") if wantarray();
  		return undef;
  	}
  
  	$S += $rs if defined $rs;
  	$carry = int($S / 60) - ($S < 0 && $S % 60 && 1);
  	$S -= $carry * 60;
  	$M += $carry;
  	$carry = int($M / 60) - ($M < 0 && $M % 60 && 1);
  	$M %= 60;
  	$H += $carry;
  	$carry = int($H / 24) - ($H < 0 && $H % 24 && 1);
  	$H %= 24;
  	$jd += $carry;
  
  	print "after rs  $jd $H $M $S\n" if $debug;
  
  	$secs = jd_secondsgm($jd, $H, $M, $S);
  	print "jd_secondsgm($jd, $H, $M, $S) = $secs\n" if $debug;
  
  	# 
  	# If we see something link 3pm CST then and we want to end
  	# up with a GMT seconds, then we convert the 3pm to GMT and
  	# subtract in the offset for CST.  We subtract because we
  	# are converting from CST to GMT.
  	#
  	my $tzadj;
  	if ($tz) {
  		$tzadj = tz_offset($tz, $secs);
  		if (defined $tzadj) {
  			print "adjusting secs for $tz: $tzadj\n" if $debug;
  			$tzadj = tz_offset($tz, $secs-$tzadj);
  			$secs -= $tzadj;
  		} else {
  			print "unknown timezone: $tz\n" if $debug;
  			undef $secs;
  			undef $t;
  		}
  	} elsif (defined $tzo) {
  		print "adjusting time for offset: $tzo\n" if $debug;
  		$secs -= $tzo;
  	} else {
  		unless ($options{GMT}) {
  			if ($options{ZONE}) {
  				$tzadj = tz_offset($options{ZONE}, $secs) || 0;
  				$tzadj = tz_offset($options{ZONE}, $secs-$tzadj);
  				unless (defined($tzadj)) {
  					return (undef, "could not convert '$options{ZONE}' to time offset")
  						if wantarray();
  					return undef;
  				}
  				print "adjusting secs for $options{ZONE}: $tzadj\n" if $debug;
  				$secs -= $tzadj;
  			} else {
  				$tzadj = tz_local_offset($secs);
  				print "adjusting secs for local offset: $tzadj\n" if $debug;
  				# 
  				# Just in case we are very close to a time
  				# change...
  				#
  				$tzadj = tz_local_offset($secs-$tzadj);
  				$secs -= $tzadj;
  			}
  		}
  	}
  
  	print "returning $secs.\n" if $debug;
  
  	return ($secs, $t) if wantarray();
  	return $secs;
  }
  
  
  sub mkoff
  {
  	my($offset) = @_;
  
  	if (defined $offset and $offset =~ s#^([-+])(\d\d):?(\d\d)$##) {
  		return ($1 eq '+' ? 
  			  3600 * $2  + 60 * $3
  			: -3600 * $2 + -60 * $3 );
  	}
  	return undef;
  }
  
  sub parse_tz_only
  {
  	my($tr, $tz, $tzo) = @_;
  
  	$$tr =~ s#^\s+##;
  	my $o;
  
  	if ($$tr =~ s#^
  			([-+]\d\d:?\d\d)
  			\s+
  			\(
  				"?
  				(?:
  					(?:
  						[A-Z]{1,4}[TCW56]
  					)
  					|
  					IDLE
  				)
  			\)
  			(?:
  				\s+
  				|
  				$ 
  			)
  			##x) { #"emacs
  		$$tzo = &mkoff($1);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^GMT\s*([-+]\d{1,2})(\s+|$)##x) {
  		$o = $1;
  		if ($o < 24 and $o !~ /^0/) {
  			# probably hours.
  			printf "adjusted at %d. ($o 00)\n", __LINE__ if $debug;
  			$o = "${o}00";
  		}
  		$o =~ s/\b(\d\d\d)/0$1/;
  		$$tzo = &mkoff($o);
  		printf "matched at %d. ($$tzo, $o)\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?:GMT\s*)?([-+]\d\d:?\d\d)(\s+|$)##x) {
  		$o = $1;
  		$$tzo = &mkoff($o);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^"?((?:[A-Z]{1,4}[TCW56])|IDLE)(?:\s+|$ )##x) { #"
  		$$tz = $1;
  		$$tz .= " DST" 
  			if $$tz eq 'MET' && $$tr =~ s#^DST(?:\s+|$ )##x;
  		printf "matched at %d: '$$tz'.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_date_only
  {
  	my ($tr, $yr, $mr, $dr, $uk) = @_;
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s#^(\d\d\d\d)([-./])(\d\d?)\2(\d\d?)(\s+|T|$)##) {
  		# yyyy/mm/dd
  
  		($$yr, $$mr, $$dr) = ($1, $3, $4);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d?)([-./])(\d\d?)\2(\d\d\d\d?)(\s+|$)##) {
  		# mm/dd/yyyy - is this safe?  No.
  		# -- or dd/mm/yyyy! If $1>12, then it's umabiguous.
  		# Otherwise check option UK for UK style date.
  		if ($uk || $1>12) {
  		  ($$yr, $$mr, $$dr) = ($4, $3, $1);
  		} else {
  		  ($$yr, $$mr, $$dr) = ($4, $1, $3);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d\d\d)/(\d\d?)(?:\s|$ )##x) {
  		# yyyy/mm
  
  		($$yr, $$mr, $$dr) = ($1, $2, 1);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:Mon|Monday|Tue|Tuesday|Wed|Wednesday|
  					Thu|Thursday|Fri|Friday|
  					Sat|Saturday|Sun|Sunday),?
  				\s+
  			)?
  			(\d\d?)
  			(\s+ | - | \. | /)
  			(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?
  			(?:
  				\2
  				(\d\d (?:\d\d)? )
  			)?
  			(?:
  				\s+
  			|
  				$
  			)
  			##) {
  		# [Dow,] dd Mon [yy[yy]]
  		($$yr, $$mr, $$dr) = ($4, $mtable{"\u\L$3"}, $1);
  
  		printf "%d: %s - %s - %s\n", __LINE__, $1, $2, $3 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:Mon|Monday|Tue|Tuesday|Wed|Wednesday|
  					Thu|Thursday|Fri|Friday|
  					Sat|Saturday|Sun|Sunday),?
  				\s+
  			)?
  			(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\.?
  			((\s)+ | - | \. | /)
  				
  			(\d\d?)
  			(?:
  				(?: \2|\3+)
  				(\d\d (?: \d\d)?)
  			)?
  			(?:
  				\s+
  			|
  				$
  			)
  			##) {
  		# [Dow,] Mon dd [yyyy]
  		($$yr, $$mr, $$dr) = ($5, $mtable{"\u\L$1"}, $4);
  		printf "%d: %s - %s - %s\n", __LINE__, $1, $2, $4 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			\s+
  			(\d+)
  			(?:st|nd|rd|th)?
  			\,?
  			(?: 
  				\s+
  				(?:
  					(\d\d\d\d)
  					|(?:\' (\d\d))
  				)
  			)?
  			(?:
  				\s+
  			|
  				$
  			)
  			##) {
  		# Month day{st,nd,rd,th}, 'yy
  		# Month day{st,nd,rd,th}, year
  		($$yr, $$mr, $$dr) = ($3 || $4, $mtable{"\u\L$1"}, $2);
  		printf "%d: %s - %s - %s - %s\n", __LINE__, $1, $2, $3, $4 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d?)([-/.])(\d\d?)\2(\d\d?)(\s+|$)##x) {
  		if ($1 > 31 || (!$uk && $1 > 12 && $4 < 32)) {
  			# yy/mm/dd
  			($$yr, $$mr, $$dr) = ($1, $3, $4);
  		} elsif ($1 > 12 || $uk) {
  			# dd/mm/yy
  			($$yr, $$mr, $$dr) = ($4, $3, $1);
  		} else {
  			# mm/dd/yy
  			($$yr, $$mr, $$dr) = ($4, $1, $3);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d?)/(\d\d?)(\s+|$)##x) {
  		if ($1 > 31 || (!$uk && $1 > 12)) {
  			# yy/mm
  			($$yr, $$mr, $$dr) = ($1, $2, 1);
  		} elsif ($2 > 31 || ($uk && $2 > 12)) {
  			# mm/yy
  			($$yr, $$mr, $$dr) = ($2, $1, 1);
  		} elsif ($1 > 12 || $uk) {
  			# dd/mm
  			($$mr, $$dr) = ($2, $1);
  		} else {
  			# mm/dd
  			($$mr, $$dr) = ($1, $2);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(\d\d)(\d\d)(\d\d)(\s+|$)##x) {
  		if ($1 > 31 || (!$uk && $1 > 12)) {
  			# YYMMDD
  			($$yr, $$mr, $$dr) = ($1, $2, $3);
  		} elsif ($1 > 12 || $uk) {
  			# DDMMYY
  			($$yr, $$mr, $$dr) = ($3, $2, $1);
  		} else {
  			# MMDDYY
  			($$yr, $$mr, $$dr) = ($3, $1, $2);
  		}
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(\d{1,2})
  			(\s+ | - | \. | /)
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			(?:
  				\2
  				(
  					\d\d
  					(?:\d\d)?
  				)
  			)
  			(:?
  				\s+
  			|
  				$
  			)
  			##) {
  		# dd Month [yr]
  		($$yr, $$mr, $$dr) = ($4, $mtable{"\u\L$3"}, $1);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(\d+)
  			(?:st|nd|rd|th)?
  			\s+
  			(January|Jan\.?|February|Feb\.?|March|Mar\.?|April|Apr\.?|May|
  			    June|Jun\.?|July|Jul\.?|August|Aug\.?|September|Sep\.?|
  			    October|Oct\.?|November|Nov\.?|December|Dec\.?)
  			(?: 
  				\,?
  				\s+
  				(\d\d\d\d)
  			)?
  			(:?
  				\s+
  			|
  				$
  			)
  			##) {
  		# day{st,nd,rd,th}, Month year
  		($$yr, $$mr, $$dr) = ($3, $mtable{"\u\L$2"}, $1);
  		printf "%d: %s - %s - %s - %s\n", __LINE__, $1, $2, $3, $4 if $debug;
  		print "y undef\n" if ($debug && ! defined($$yr));
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_time_only
  {
  	my ($tr, $hr, $mr, $sr, $tzr, %options) = @_;
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s!^(?x)
  			(?:
  				(?:
  					([012]\d)		(?# $1)
  					(?:
  						([0-5]\d) 	(?# $2)
  						(?:
  						    ([0-5]\d)	(?# $3)
  						)?
  					)
  					\s*
  					([apAP][mM])?  		(?# $4)
  				) | (?:
  					(\d{1,2}) 		(?# $5)
  					(?:
  						\:
  						(\d\d)		(?# $6)
  						(?:
  							\:
  							(\d\d)	(?# $7)
  								(
  									(?# don't barf on database sub-second timings)
  									[:.,]
  									\d{1,6}
  								)?	(?# $8)
  						)?
  					)
  					\s*
  					([apAP][mM])?		(?# $9)
  				) | (?:
  					(\d{1,2})		(?# $10)
  					([apAP][mM])		(?# ${11})
  				)
  			)
  			(?:
  				\s+
  				"?
  				(				(?# ${12})
  					(?: [A-Z]{1,4}[TCW56] )
  					|
  					IDLE
  				)	
  			)?
  			(?:
  				\s*
  			|
  				$
  			)
  			!!) { #"emacs
  		# HH[[:]MM[:SS]]meridan [zone] 
  		my $ampm;
  		$$hr = $1 || $5 || $10 || 0; # 10 is undef, but 5 is defined..
  		$$mr = $2 || $6 || 0;
  		$$sr = $3 || $7 || 0;
  		if (defined($8) && exists($options{SUBSECOND}) && $options{SUBSECOND}) {
  			my($frac) = $8;
  			substr($frac,0,1) = '.';
  			$$sr += $frac;
  		}
  		print "S = $$sr\n" if $debug;
  		$ampm = $4 || $9 || $11 || '';
  		$$tzr = $12;
  		$$hr += 12 if $ampm and "\U$ampm" eq "PM" && $$hr != 12;
  		$$hr = 0 if $$hr == 12 && "\U$ampm" eq "AM";
  		printf "matched at %d, rem = %s.\n", __LINE__, $$tr if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^noon(?:\s+|$ )##ix) {
  		# noon
  		($$hr, $$mr, $$sr) = (12, 0, 0);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^midnight(?:\s+|$ )##ix) {
  		# midnight
  		($$hr, $$mr, $$sr) = (0, 0, 0);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_time_offset
  {
  	my ($tr, $rsr, %options) = @_;
  
  	$$tr =~ s/^\s+//;
  
  	return 0 if $options{NO_RELATIVE};
  
  	if ($$tr =~ s{^(?xi)					
  			(?:
  				(-)				(?# 1)
  				|
  				[+]
  			)?
  			\s*
  			(?:
  				(\d+(?:\.\d+)?) 		(?# 2)
  				| 		
  				(?:(\d+)\s+(\d+)/(\d+))		(?# 3 4/5)
  			)
  			\s*
  			(sec|second|min|minute|hour)s?		(?# 6)
  			(
  				\s+
  				ago				(?# 7)
  			)?
  			(?:
  				\s+
  				|
  				$
  			)
  			}{}) {
  		# count units
  		$$rsr = 0 unless defined $$rsr;
  		return 0 if defined($5) && $5 == 0;
  		my $num = defined($2)
  			? $2
  			: $3 + $4/$5;
  		$num = -$num if $1;
  		$$rsr += $umult{"\L$6"} * $num;
  
  		$$rsr = -$$rsr if $7 ||
  			$$tr =~ /\b(day|mon|month|year)s?\s*ago\b/;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} 
  	return 0;
  }
  
  #
  # What to you do with a date that has a two-digit year?
  # There's not much that can be done except make a guess.
  #
  # Some example situations to handle:
  #
  #	now		year 
  #
  #	1999		01
  #	1999		71
  #	2010		71
  #	2110		09
  #
  
  sub expand_two_digit_year
  {
  	my ($yr, $now, %options) = @_;
  
  	return $yr if $yr > 100;
  
  	my ($y) = (&righttime($now, %options))[5];
  	$y += 1900;
  	my $century = int($y / 100) * 100;
  	my $within = $y % 100;
  
  	my $r = $yr + $century;
  
  	if ($options{PREFER_PAST}) {
  		if ($yr > $within) {
  			$r = $yr + $century - 100;
  		}
  	} elsif ($options{PREFER_FUTURE}) {
  		# being strict here would be silly
  		if ($yr < $within-20) {
  			# it's 2019 and the date is '08'
  			$r = $yr + $century + 100;
  		}
  	} elsif ($options{UNAMBIGUOUS}) {
  		# we really shouldn't guess
  		return undef;
  	} else {
  		# prefer the current century in most cases
  
  		if ($within > 80 && $within - $yr > 60) {
  			$r = $yr + $century + 100;
  		}
  
  		if ($within < 30 && $yr - $within > 59) {
  			$r = $yr + $century - 100;
  		}
  	}
  	print "two digit year '$yr' expanded into $r\n" if $debug;
  	return $r;
  }
  
  
  sub calc 
  {
  	my ($rsr, $yr, $mr, $dr, $rdr, $now, $units, $count, %options) = @_;
  
  	confess unless $units;
  	$units = "\L$units";
  	print "calc based on $units\n" if $debug;
  
  	if ($units eq 'day') {
  		$$rdr = $count;
  	} elsif ($units eq 'week') {
  		$$rdr = $count * 7;
  	} elsif ($umult{$units}) {
  		$$rsr = $count * $umult{$units};
  	} elsif ($units eq 'mon' || $units eq 'month') {
  		($$yr, $$mr, $$dr) = &monthoff($now, $count, %options);
  		$$rsr = 0 unless $$rsr;
  	} elsif ($units eq 'year') {
  		($$yr, $$mr, $$dr) = &monthoff($now, $count * 12, %options);
  		$$rsr = 0 unless $$rsr;
  	} else {
  		carp "interal error";
  	}
  	print "calced rsr $$rsr rdr $$rdr, yr $$yr mr $$mr dr $$dr.\n" if $debug;
  }
  
  sub monthoff
  {
  	my ($now, $months, %options) = @_;
  
  	# months are 0..11
  	my ($d, $m11, $y) = (&righttime($now, %options)) [ 3,4,5 ] ;
  
  	$y += 1900;
  
  	print "m11 = $m11 + $months, y = $y\n" if $debug;
  
  	$m11 += $months;
  
  	print "m11 = $m11, y = $y\n" if $debug;
  	if ($m11 > 11 || $m11 < 0) {
  		$y -= 1 if $m11 < 0 && ($m11 % 12 != 0);
  		$y += int($m11/12);
  
  		# this is required to work around a bug in perl 5.003
  		no integer;
  		$m11 %= 12;
  	}
  	print "m11 = $m11, y = $y\n" if $debug;
  
  	# 
  	# What is "1 month from January 31st?"  
  	# I think the answer is February 28th most years.
  	#
  	# Similarly, what is one year from February 29th, 1980?
  	# I think it's February 28th, 1981.
  	#
  	# If you disagree, change the following code.
  	#
  	if ($d > 30 or ($d > 28 && $m11 == 1)) {
  		require Time::DaysInMonth;
  		my $dim = Time::DaysInMonth::days_in($y, $m11+1);
  		print "dim($y,$m11+1)= $dim\n" if $debug;
  		$d = $dim if $d > $dim;
  	}
  	return ($y, $m11+1, $d);
  }
  
  sub righttime
  {
  	my ($time, %options) = @_;
  	if ($options{GMT}) {
  		return gmtime($time);
  	} else {
  		return localtime($time);
  	}
  }
  
  sub parse_year_only
  {
  	my ($tr, $yr, $now, %options) = @_;
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s#^(\d\d\d\d)(?:\s+|$)##) {
  		$$yr = $1;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#\'(\d\d)(?:\s+|$ )##) {
  		$$yr = expand_two_digit_year($1, $now, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	}
  	return 0;
  }
  
  sub parse_date_offset
  {
  	my ($tr, $now, $yr, $mr, $dr, $rdr, $rsr, %options) = @_;
  
  	return 0 if $options{NO_RELATIVE};
  
  	# now - current seconds_since_epoch
  	# yr - year return
  	# mr - month return
  	# dr - day return
  	# rdr - relatvie day return
  	# rsr - relative second return
  
  	my $j;
  	my $wday = (&righttime($now, %options))[6];
  
  	$$tr =~ s#^\s+##;
  
  	if ($$tr =~ s#^(?xi)
  			\s*
  			(\d+)
  			\s*
  			(day|week|month|year)s?
  			(
  				\s+
  				ago
  			)?
  			(?:
  				\s+
  				|
  				$
  			)
  			##) {
  		my $amt = $1 + 0;
  		my $units = $2;
  		$amt = -$amt if $3 ||
  			$$tr =~ m#\b(sec|second|min|minute|hour)s?\s*ago\b#;
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $units, 
  			$amt, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(?:
  				(?:
  					now
  					\s+
  				)?
  				(\+ | \-)
  				\s*
  			)?
  			(\d+)
  			\s*
  			(day|week|month|year)s?
  			(?:
  				\s+
  				|
  				$
  			)
  			##) {
  		my $one = $1 || '';
  		my $two = $2 || '';
  		my $amt = "$one$two"+0;
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $3, 
  			$amt, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			\s+
  			after
  			\s+
  			next
  			(?: \s+ | $ )
  			##) {
  		# Dow "after next"
  		$$rdr = $wdays{"\L$1"} - $wday + ( $wdays{"\L$1"} > $wday ? 7 : 14);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			\s+
  			before
  			\s+
  			last
  			(?: \s+ | $ )
  			##) {
  		# Dow "before last"
  		$$rdr = $wdays{"\L$1"} - $wday - ( $wdays{"\L$1"} < $wday ? 7 : 14);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			next\s+
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			(?:\s+|$ )
  			##) {
  		# "next" Dow
  		$$rdr = $wdays{"\L$1"} - $wday 
  				+ ( $wdays{"\L$1"} > $wday ? 0 : 7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^(?xi)
  			last\s+
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			(?:\s+|$ )##) {
  		# "last" Dow
  		printf "c %d - %d + ( %d < %d ? 0 : -7 \n", $wdays{"\L$1"},  $wday,  $wdays{"\L$1"}, $wday if $debug;
  		$$rdr = $wdays{"\L$1"} - $wday + ( $wdays{"\L$1"} < $wday ? 0 : -7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($options{PREFER_PAST} and $$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			(?:\s+|$ )##) {
  		# Dow
  		printf "c %d - %d + ( %d < %d ? 0 : -7 \n", $wdays{"\L$1"},  $wday,  $wdays{"\L$1"}, $wday if $debug;
  		$$rdr = $wdays{"\L$1"} - $wday + ( $wdays{"\L$1"} < $wday ? 0 : -7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($options{PREFER_FUTURE} and $$tr =~ s#^(?xi)
  			(Mon|Tue|Wed|Thu|Fri|Sat|Sun|Monday|Tuesday
  				|Wednesday|Thursday|Friday|Saturday|Sunday)
  			(?:\s+|$ )
  			##) {
  		# Dow
  		$$rdr = $wdays{"\L$1"} - $wday 
  				+ ( $wdays{"\L$1"} > $wday ? 0 : 7);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^today(?:\s+|$ )##xi) {
  		# today
  		$$rdr = 0;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^tomorrow(?:\s+|$ )##xi) {
  		$$rdr = 1;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^yesterday(?:\s+|$ )##xi) {
  		$$rdr = -1;
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^last\s+(week|month|year)(?:\s+|$ )##xi) {
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $1, -1, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^next\s+(week|month|year)(?:\s+|$ )##xi) {
  		&calc($rsr, $yr, $mr, $dr, $rdr, $now, $1, 1, %options);
  		printf "matched at %d.\n", __LINE__ if $debug;
  		return 1;
  	} elsif ($$tr =~ s#^now (?: \s+ | $ )##x) {
  		$$rdr = 0;
  		return 1;
  	}
  	return 0;
  }
  
  sub debug_display
  {
  	my ($tz, $tzo, $H, $M, $S, $m, $d, $y, $rs, $rd, $rel, $passes, $parse, $t) = @_;
  	print "---------<<\n";
  	print defined($tz) ? "tz: $tz.\n" : "no tz\n";
  	print defined($tzo) ? "tzo: $tzo.\n" : "no tzo\n";
  	print "HMS: ";
  	print defined($H) ? "$H, " : "no H, ";
  	print defined($M) ? "$M, " : "no M, ";
  	print defined($S) ? "$S\n" : "no S.\n";
  	print "mdy: ";
  	print defined($m) ? "$m, " : "no m, ";
  	print defined($d) ? "$d, " : "no d, ";
  	print defined($y) ? "$y\n" : "no y.\n";
  	print defined($rs) ? "rs: $rs.\n" : "no rs\n";
  	print defined($rd) ? "rd: $rd.\n" : "no rd\n";
  	print $rel ? "relative\n" : "not relative\n";
  	print "passes: $passes\n";
  	print "parse:$parse\n";
  	print "t: $t.\n";
  	print "--------->>\n";
  }
  1;
  
  __END__
  
  =head1 NAME
  
  Time::ParseDate -- date parsing both relative and absolute
  
  =head1 SYNOPSIS
  
  	use Time::ParseDate;
  	$seconds_since_jan1_1970 = parsedate("12/11/94 2pm", NO_RELATIVE => 1)
  	$seconds_since_jan1_1970 = parsedate("12/11/94 2pm", %options)
  
  =head1 OPTIONS
  
  Date parsing can also use options.  The options are as follows:
  
  	FUZZY	-> it's okay not to parse the entire date string
  	NOW	-> the "current" time for relative times (defaults to time())
  	ZONE	-> local timezone (defaults to $ENV{TZ})
  	WHOLE	-> the whole input string must be parsed
  	GMT	-> input time is assumed to be GMT, not localtime
  	UK	-> prefer UK style dates (dd/mm over mm/dd)
  	DATE_REQUIRED -> do not default the date
  	TIME_REQUIRED -> do not default the time
  	NO_RELATIVE -> input time is not relative to NOW
  	TIMEFIRST -> try parsing time before date [not default]
  	PREFER_PAST -> when year or day of week is ambigueous, assume past
  	PREFER_FUTURE -> when year or day of week is ambigueous, assume future
  	SUBSECOND -> parse fraction seconds
  	VALIDATE -> only accept normal values for HHMMSS, YYMMDD.  Otherwise
  		days like -1 might give the last day of the previous month.
  
  =head1 DATE FORMATS RECOGNIZED
  
  =head2 Absolute date formats
  
  	Dow, dd Mon yy
  	Dow, dd Mon yyyy
  	Dow, dd Mon
  	dd Mon yy
  	dd Mon yyyy
  	Month day{st,nd,rd,th}, year
  	Month day{st,nd,rd,th}
  	Mon dd yyyy
  	yyyy/mm/dd
  	yyyy-mm-dd	(usually the best date specification syntax)
  	yyyy/mm
  	mm/dd/yy
  	mm/dd/yyyy
  	mm/yy
  	yy/mm      (only if year > 12, or > 31 if UK)
  	yy/mm/dd   (only if year > 12 and day < 32, or year > 31 if UK)
  	dd/mm/yy   (only if UK, or an invalid mm/dd/yy or yy/mm/dd)
  	dd/mm/yyyy (only if UK, or an invalid mm/dd/yyyy)
  	dd/mm      (only if UK, or an invalid mm/dd)
  
  =head2 Relative date formats:
  
  	count "days"
  	count "weeks"
  	count "months"
  	count "years"
  	Dow "after next"
  	Dow "before last"
  	Dow 			(requires PREFER_PAST or PREFER_FUTURE)
  	"next" Dow
  	"tomorrow"
  	"today"
  	"yesterday"
  	"last" dow
  	"last week"
  	"now"
  	"now" "+" count units
  	"now" "-" count units
  	"+" count units		
  	"-" count units
  	count units "ago"
  
  =head2 Absolute time formats:
  
  	hh:mm:ss[.ddd] 
  	hh:mm 
  	hh:mm[AP]M
  	hh[AP]M
  	hhmmss[[AP]M] 
  	"noon"
  	"midnight"
  
  =head2 Relative time formats:
  
  	count "minutes"		(count can be franctional "1.5" or "1 1/2")
  	count "seconds"
  	count "hours"
  	"+" count units
  	"+" count
  	"-" count units
  	"-" count
  	count units "ago"
  
  =head2 Timezone formats:
  
  	[+-]dddd
  	GMT[+-]d+
  	[+-]dddd (TZN)
  	TZN
  
  =head2 Special formats:
  
  	[ d]d/Mon/yyyy:hh:mm:ss [[+-]dddd]
  	yy/mm/dd.hh:mm
  
  =head1 DESCRIPTION
  
  This module recognizes the above date/time formats.   Usually a
  date and a time are specified.  There are numerous options for 
  controlling what is recognized and what is not.
  
  The return code is always the time in seconds since January 1st, 1970
  or undef if it was unable to parse the time.
  
  If a timezone is specified it must be after the time.  Year specifications
  can be tacked onto the end of absolute times.
  
  If C<parsedate()> is called from array context, then it will return two
  elements.  On sucessful parses, it will return the seconds and what 
  remains of its input string.  On unsucessful parses, it will return
  C<undef> and an error string.
  
  =head1 EXAMPLES
  
  	$seconds = parsedate("Mon Jan  2 04:24:27 1995");
  	$seconds = parsedate("Tue Apr 4 00:22:12 PDT 1995");
  	$seconds = parsedate("04.04.95 00:22", ZONE => PDT);
  	$seconds = parsedate("Jan 1 1999 11:23:34.578", SUBSECOND => 1);
  	$seconds = parsedate("122212 950404", ZONE => PDT, TIMEFIRST => 1);
  	$seconds = parsedate("+3 secs", NOW => 796978800);
  	$seconds = parsedate("2 months", NOW => 796720932);
  	$seconds = parsedate("last Tuesday");
  	$seconds = parsedate("Sunday before last");
  
  	($seconds, $remaining) = parsedate("today is the day");
  	($seconds, $error) = parsedate("today is", WHOLE=>1);
  
  =head1 LICENSE
  
  Copyright (C) 1996-2010 David Muir Sharnoff.  
  Copyright (C) 2011 Google, Inc.  
  License hereby
  granted for anyone to use, modify or redistribute this module at
  their own risk.  Please feed useful changes back to cpan@dave.sharnoff.org.
  
TIME_PARSEDATE

$fatpacked{"Time/Timezone.pm"} = <<'TIME_TIMEZONE';
  
  package Time::Timezone;
  
  require 5.002;
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(tz2zone tz_local_offset tz_offset tz_name);
  @EXPORT_OK = qw();
  
  use Carp;
  use strict;
  
  # Parts stolen from code by Paul Foley <paul@ascent.com>
  
  use vars qw($VERSION);
  
  $VERSION = 2006.0814;
  
  sub tz2zone
  {
  	my($TZ, $time, $isdst) = @_;
  
  	use vars qw(%tzn_cache);
  
  	$TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : ''
  	    unless $TZ;
  
  	# Hack to deal with 'PST8PDT' format of TZ
  	# Note that this can't deal with all the esoteric forms, but it
  	# does recognize the most common: [:]STDoff[DST[off][,rule]]
  
  	if (! defined $isdst) {
  		my $j;
  		$time = time() unless $time;
  		($j, $j, $j, $j, $j, $j, $j, $j, $isdst) = localtime($time);
  	}
  
  	if (defined $tzn_cache{$TZ}->[$isdst]) {
  		return $tzn_cache{$TZ}->[$isdst];
  	}
        
  	if ($TZ =~ /^
  		    ( [^:\d+\-,] {3,} )
  		    ( [+-] ?
  		      \d {1,2}
  		      ( : \d {1,2} ) {0,2} 
  		    )
  		    ( [^\d+\-,] {3,} )?
  		    /x
  	    ) {
  		$TZ = $isdst ? $4 : $1;
  		$tzn_cache{$TZ} = [ $1, $4 ];
  	} else {
  		$tzn_cache{$TZ} = [ $TZ, $TZ ];
  	}
  	return $TZ;
  }
  
  sub tz_local_offset
  {
  	my ($time) = @_;
  
  	$time = time() unless $time;
  	my (@l) = localtime($time);
  	my $isdst = $l[8] || 0;
  	my $tzenv = defined($ENV{TZ}) ? $ENV{TZ} : "__notz";
  
  	if ($Timezone::tz_local{$tzenv} &&
  	    defined($Timezone::tz_local{$tzenv}[$isdst])) {
  		return $Timezone::tz_local{$tzenv}[$isdst];
  	}
  
  	$Timezone::tz_local{$tzenv}[$isdst] = &calc_off($time);
  
  	return $Timezone::tz_local{$tzenv}[$isdst];
  }
  
  sub calc_off
  {
  	my ($time) = @_;
  
  	my (@l) = localtime($time);
  	my (@g) = gmtime($time);
  
  	my $off;
  
  	$off =	   $l[0] - $g[0]
  		+ ($l[1] - $g[1]) * 60
  		+ ($l[2] - $g[2]) * 3600;
  
  	# subscript 7 is yday.
  
  	if ($l[7] == $g[7]) {
  		# done
  	} elsif ($l[7] == $g[7] + 1) {
  		$off += 86400;
  	} elsif ($l[7] == $g[7] - 1) {
  		$off -= 86400;
  	} elsif ($l[7] < $g[7]) {
  		# crossed over a year boundry!
  		# localtime is beginning of year, gmt is end
  		# therefore local is ahead
  		$off += 86400;
  	} else {
  		$off -= 86400;
  	}
  
  	return $off;
  }
  
  # constants
  # The rest of the file originally comes from Graham Barr <bodg@tiuk.ti.com> 
  #
  # Some references:
  #  http://www.weltzeituhr.com/laender/zeitzonen_e.shtml
  #  http://www.worldtimezone.com/wtz-names/timezonenames.html
  #  http://www.timegenie.com/timezones.php
  
  CONFIG: {
  	use vars qw(%dstZone %zoneOff %dstZoneOff %Zone);
  
  	%dstZone = (
  	    "brst" =>	-2*3600,	 # Brazil Summer Time (East Daylight)
  	    "adt"  =>	-3*3600,	 # Atlantic Daylight   
  	    "edt"  =>	-4*3600,	 # Eastern Daylight
  	    "cdt"  =>	-5*3600,	 # Central Daylight
  	    "mdt"  =>	-6*3600,	 # Mountain Daylight
  	    "pdt"  =>	-7*3600,	 # Pacific Daylight
  	    "ydt"  =>	-8*3600,	 # Yukon Daylight
  	    "hdt"  =>	-9*3600,	 # Hawaii Daylight
  	    "bst"  =>	+1*3600,	 # British Summer   
  	    "mest" =>	+2*3600,	 # Middle European Summer   
  	    "met dst" => +2*3600,	 # Middle European Summer   
  	    "sst"  =>	+2*3600,	 # Swedish Summer
  	    "fst"  =>	+2*3600,	 # French Summer
  	    "eest" =>	+3*3600,	 # Eastern European Summer
  	    "cest" =>	+2*3600,	 # Central European Daylight
  	    "wadt" =>	+8*3600,	 # West Australian Daylight
  	    "kdt"  =>  +10*3600,	 # Korean Daylight
  	#   "cadt" =>  +10*3600+1800,	 # Central Australian Daylight
  	    "eadt" =>  +11*3600,	 # Eastern Australian Daylight
  	    "nzdt" =>  +13*3600,	 # New Zealand Daylight	  
  	);
  
  	# not included due to ambiguity:
  	#	IST     Indian Standard Time            +5.5
  	#		Ireland Standard Time           0
  	#		Israel Standard Time            +2
  	#	IDT     Ireland Daylight Time           +1
  	#		Israel Daylight Time            +3
  	#	AMST    Amazon Standard Time /          -3
  	#		Armenia Standard Time           +8
  	#	BST	Brazil Standard			-3
  
  	%Zone = (
  	    "gmt"	=>   0,		 # Greenwich Mean
  	    "ut"	=>   0,		 # Universal (Coordinated)
  	    "utc"	=>   0,
  	    "wet"	=>   0,		 # Western European
  	    "wat"	=>  -1*3600,	 # West Africa
  	    "azost"	=>  -1*3600,	 # Azores Standard Time
  	    "cvt"	=>  -1*3600,	 # Cape Verde Time
  	    "at"	=>  -2*3600,	 # Azores
  	    "fnt"	=>  -2*3600,	 # Brazil Time (Extreme East - Fernando Noronha)
  	    "ndt" 	=>  -2*3600-1800,# Newfoundland Daylight   
  	    "art"	=>  -3*3600,	 # Argentina Time
  	# For completeness.  BST is also British Summer, and GST is also Guam Standard.
  	#   "gst"	=>  -3*3600,	 # Greenland Standard
  	    "nft"	=>  -3*3600-1800,# Newfoundland
  	#   "nst"	=>  -3*3600-1800,# Newfoundland Standard
  	    "mnt"	=>  -4*3600,	 # Brazil Time (West Standard - Manaus)
  	    "ewt"	=>  -4*3600,	 # U.S. Eastern War Time
  	    "ast"	=>  -4*3600,	 # Atlantic Standard
  	    "bot"	=>  -4*3600,	 # Bolivia Time
  	    "vet"	=>  -4*3600,	 # Venezuela Time
  	    "est"	=>  -5*3600,	 # Eastern Standard
  	    "cot"	=>  -5*3600,	 # Colombia Time
  	    "act"	=>  -5*3600,	 # Brazil Time (Extreme West - Acre)
  	    "pet"	=>  -5*3600,	 # Peru Time
  	    "cst"	=>  -6*3600,	 # Central Standard
  	    "cest"	=>  +2*3600,	 # Central European Summer
  	    "mst"	=>  -7*3600,	 # Mountain Standard
  	    "pst"	=>  -8*3600,	 # Pacific Standard
  	    "yst"	=>  -9*3600,	 # Yukon Standard
  	    "hst"	=> -10*3600,	 # Hawaii Standard
  	    "cat"	=> -10*3600,	 # Central Alaska
  	    "ahst"	=> -10*3600,	 # Alaska-Hawaii Standard
  	    "taht"	=> -10*3600,	 # Tahiti Time
  	    "nt"	=> -11*3600,	 # Nome
  	    "idlw"	=> -12*3600,	 # International Date Line West
  	    "cet"	=>  +1*3600,	 # Central European
  	    "mez"	=>  +1*3600,	 # Central European (German)
  	    "met"	=>  +1*3600,	 # Middle European
  	    "mewt"	=>  +1*3600,	 # Middle European Winter
  	    "swt"	=>  +1*3600,	 # Swedish Winter
  	    "set"	=>  +1*3600,	 # Seychelles
  	    "fwt"	=>  +1*3600,	 # French Winter
  	    "west"	=>  +1*3600,	 # Western Europe Summer Time
  	    "eet"	=>  +2*3600,	 # Eastern Europe, USSR Zone 1
  	    "ukr"	=>  +2*3600,	 # Ukraine
  	    "sast"	=>  +2*3600,	 # South Africa Standard Time
  	    "bt"	=>  +3*3600,	 # Baghdad, USSR Zone 2
  	    "eat"	=>  +3*3600,	 # East Africa Time
  	#   "it"	=>  +3*3600+1800,# Iran
  	    "irst"	=>  +3*3600+1800,# Iran Standard Time
  	    "zp4"	=>  +4*3600,	 # USSR Zone 3
  	    "msd"	=>  +4*3600,	 # Moscow Daylight Time
  	    "sct"	=>  +4*3600,	 # Seychelles Time
  	    "zp5"	=>  +5*3600,	 # USSR Zone 4
  	    "azst"	=>  +5*3600,	 # Azerbaijan Summer Time
  	    "mvt"	=>  +5*3600,	 # Maldives Time
  	    "uzt"	=>  +5*3600,	 # Uzbekistan Time
  	    "ist"	=>  +5*3600+1800,# Indian Standard
  	    "zp6"	=>  +6*3600,	 # USSR Zone 5
  	    "lkt"	=>  +6*3600,	 # Sri Lanka Time
  	    "pkst"	=>  +6*3600,	 # Pakistan Summer Time
  	    "yekst"	=>  +6*3600,	 # Yekaterinburg Summer Time
  	# For completeness.  NST is also Newfoundland Stanard, and SST is also Swedish Summer.
  	#   "nst"	=>  +6*3600+1800,# North Sumatra
  	#   "sst"	=>  +7*3600,	 # South Sumatra, USSR Zone 6
  	    "wast"	=>  +7*3600,	 # West Australian Standard
  	    "ict"	=>  +7*3600,	 # Indochina Time
  	    "wit"	=>  +7*3600,	 # Western Indonesia Time
  	#   "jt"	=>  +7*3600+1800,# Java (3pm in Cronusland!)
  	    "cct"	=>  +8*3600,	 # China Coast, USSR Zone 7
  	    "wst"	=>  +8*3600,	 # West Australian Standard
  	    "hkt"	=>  +8*3600,	 # Hong Kong
  	    "bnt"	=>  +8*3600,	 # Brunei Darussalam Time
  	    "cit"	=>  +8*3600,	 # Central Indonesia Time
  	    "myt"	=>  +8*3600,	 # Malaysia Time
  	    "pht"	=>  +8*3600,	 # Philippines Time
  	    "sgt"	=>  +8*3600,	 # Singapore Time
  	    "jst"	=>  +9*3600,	 # Japan Standard, USSR Zone 8
  	    "kst"	=>  +9*3600,	 # Korean Standard
  	#   "cast"	=>  +9*3600+1800,# Central Australian Standard
  	    "east"	=> +10*3600,	 # Eastern Australian Standard
  	    "gst"	=> +10*3600,	 # Guam Standard, USSR Zone 9
  	    "nct"	=> +11*3600,	 # New Caledonia Time
  	    "nzt"	=> +12*3600,	 # New Zealand
  	    "nzst"	=> +12*3600,	 # New Zealand Standard
  	    "fjt"	=> +12*3600,	 # Fiji Time
  	    "idle"	=> +12*3600,	 # International Date Line East
  	);
  
  	%zoneOff = reverse(%Zone);
  	%dstZoneOff = reverse(%dstZone);
  
  	# Preferences
  
  	$zoneOff{0}	  = 'gmt';
  	$dstZoneOff{3600} = 'bst';
  
  }
  
  sub tz_offset
  {
  	my ($zone, $time) = @_;
  
  	return &tz_local_offset() unless($zone);
  
  	$time = time() unless $time;
  	my(@l) = localtime($time);
  	my $dst = $l[8];
  
  	$zone = lc $zone;
  
  	if ($zone =~ /^([\-\+]\d{3,4})$/) {
  		my $sign = $1 < 0 ? -1 : 1 ;
  		my $v = abs(0 + $1);
  		return $sign * 60 * (int($v / 100) * 60 + ($v % 100));
  	} elsif (exists $dstZone{$zone} && ($dst || !exists $Zone{$zone})) {
  		return $dstZone{$zone};
  	} elsif(exists $Zone{$zone}) {
  		return $Zone{$zone};
  	}
  	undef;
  }
  
  sub tz_name
  {
  	my ($off, $time) = @_;
  
  	$time = time() unless $time;
  	my(@l) = localtime($time);
  	my $dst = $l[8];
  
  	if (exists $dstZoneOff{$off} && ($dst || !exists $zoneOff{$off})) {
  		return $dstZoneOff{$off};
  	} elsif (exists $zoneOff{$off}) {
  		return $zoneOff{$off};
  	}
  	sprintf("%+05d", int($off / 60) * 100 + $off % 60);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Time::Timezone -- miscellaneous timezone manipulations routines
  
  =head1 SYNOPSIS
  
  	use Time::Timezone;
  	print tz2zone();
  	print tz2zone($ENV{'TZ'});
  	print tz2zone($ENV{'TZ'}, time());
  	print tz2zone($ENV{'TZ'}, undef, $isdst);
  	$offset = tz_local_offset();
  	$offset = tz_offset($TZ);
  
  =head1 DESCRIPTION
  
  This is a collection of miscellaneous timezone manipulation routines.
  
  C<tz2zone()> parses the TZ environment variable and returns a timezone
  string suitable for inclusion in L<date>-like output.  It opionally takes
  a timezone string, a time, and a is-dst flag.
  
  C<tz_local_offset()> determins the offset from GMT time in seconds.  It
  only does the calculation once.
  
  C<tz_offset()> determines the offset from GMT in seconds of a specified
  timezone.  
  
  C<tz_name()> determines the name of the timezone based on its offset
  
  =head1 AUTHORS
  
  Graham Barr <bodg@tiuk.ti.com>
  David Muir Sharnoff <muir@idiom.org>
  Paul Foley <paul@ascent.com>
  
  =head1 LICENSE
  
  David Muir Sharnoff disclaims any copyright and puts his contribution
  to this module in the public domain.
  
TIME_TIMEZONE

$fatpacked{"Time/Zone.pm"} = <<'TIME_ZONE';
  
  package Time::Zone;
  
  =head1 NAME
  
  Time::Zone -- miscellaneous timezone manipulations routines
  
  =head1 SYNOPSIS
  
  	use Time::Zone;
  	print tz2zone();
  	print tz2zone($ENV{'TZ'});
  	print tz2zone($ENV{'TZ'}, time());
  	print tz2zone($ENV{'TZ'}, undef, $isdst);
  	$offset = tz_local_offset();
  	$offset = tz_offset($TZ);
  
  =head1 DESCRIPTION
  
  This is a collection of miscellaneous timezone manipulation routines.
  
  C<tz2zone()> parses the TZ environment variable and returns a timezone
  string suitable for inclusion in L<date(1)>-like output.  It opionally takes
  a timezone string, a time, and a is-dst flag.
  
  C<tz_local_offset()> determins the offset from GMT time in seconds.  It
  only does the calculation once.
  
  C<tz_offset()> determines the offset from GMT in seconds of a specified
  timezone.  
  
  C<tz_name()> determines the name of the timezone based on its offset
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  David Muir Sharnoff <muir@idiom.com>
  Paul Foley <paul@ascent.com>
  
  =cut
  
  require 5.002;
  
  require Exporter;
  use Carp;
  use strict;
  use vars qw(@ISA @EXPORT $VERSION @tz_local);
  
  @ISA = qw(Exporter);
  @EXPORT = qw(tz2zone tz_local_offset tz_offset tz_name);
  $VERSION = "2.24";
  
  # Parts stolen from code by Paul Foley <paul@ascent.com>
  
  sub tz2zone (;$$$)
  {
  	my($TZ, $time, $isdst) = @_;
  
  	use vars qw(%tzn_cache);
  
  	$TZ = defined($ENV{'TZ'}) ? ( $ENV{'TZ'} ? $ENV{'TZ'} : 'GMT' ) : ''
  	    unless $TZ;
  
  	# Hack to deal with 'PST8PDT' format of TZ
  	# Note that this can't deal with all the esoteric forms, but it
  	# does recognize the most common: [:]STDoff[DST[off][,rule]]
  
  	if (! defined $isdst) {
  		my $j;
  		$time = time() unless $time;
  		($j, $j, $j, $j, $j, $j, $j, $j, $isdst) = localtime($time);
  	}
  
  	if (defined $tzn_cache{$TZ}->[$isdst]) {
  		return $tzn_cache{$TZ}->[$isdst];
  	}
        
  	if ($TZ =~ /^
  		    ( [^:\d+\-,] {3,} )
  		    ( [+-] ?
  		      \d {1,2}
  		      ( : \d {1,2} ) {0,2} 
  		    )
  		    ( [^\d+\-,] {3,} )?
  		    /x
  	    ) {
  		my $dsttz = defined($4) ? $4 : $1;
  		$TZ = $isdst ? $dsttz : $1;
  		$tzn_cache{$TZ} = [ $1, $dsttz ];
  	} else {
  		$tzn_cache{$TZ} = [ $TZ, $TZ ];
  	}
  	return $TZ;
  }
  
  sub tz_local_offset (;$)
  {
  	my ($time) = @_;
  
  	$time = time() unless $time;
  	my (@l) = localtime($time);
  	my $isdst = $l[8];
  
  	if (defined($tz_local[$isdst])) {
  		return $tz_local[$isdst];
  	}
  
  	$tz_local[$isdst] = &calc_off($time);
  
  	return $tz_local[$isdst];
  }
  
  sub calc_off
  {
  	my ($time) = @_;
  
  	my (@l) = localtime($time);
  	my (@g) = gmtime($time);
  
  	my $off;
  
  	$off =     $l[0] - $g[0]
  		+ ($l[1] - $g[1]) * 60
  		+ ($l[2] - $g[2]) * 3600;
  
  	# subscript 7 is yday.
  
  	if ($l[7] == $g[7]) {
  		# done
  	} elsif ($l[7] == $g[7] + 1) {
  		$off += 86400;
  	} elsif ($l[7] == $g[7] - 1) {
  		$off -= 86400;
  	} elsif ($l[7] < $g[7]) {
  		# crossed over a year boundry!
  		# localtime is beginning of year, gmt is end
  		# therefore local is ahead
  		$off += 86400;
  	} else {
  		$off -= 86400;
  	}
  
  	return $off;
  }
  
  # constants
  
  CONFIG: {
  	use vars qw(%dstZone %zoneOff %dstZoneOff %Zone);
  
  	my @dstZone = (
  	#   "ndt"  =>   -2*3600-1800,	 # Newfoundland Daylight   
  	    "brst" =>   -2*3600,         # Brazil Summer Time (East Daylight)
  	    "adt"  =>   -3*3600,  	 # Atlantic Daylight   
  	    "edt"  =>   -4*3600,  	 # Eastern Daylight
  	    "cdt"  =>   -5*3600,  	 # Central Daylight
  	    "mdt"  =>   -6*3600,  	 # Mountain Daylight
  	    "pdt"  =>   -7*3600,  	 # Pacific Daylight
  	    "akdt" =>   -8*3600,         # Alaska Daylight
  	    "ydt"  =>   -8*3600,  	 # Yukon Daylight
  	    "hdt"  =>   -9*3600,  	 # Hawaii Daylight
  	    "bst"  =>   +1*3600,  	 # British Summer   
  	    "mest" =>   +2*3600,  	 # Middle European Summer   
  	    "metdst" => +2*3600, 	 # Middle European DST
  	    "sst"  =>   +2*3600,  	 # Swedish Summer
  	    "fst"  =>   +2*3600,  	 # French Summer
              "cest" =>   +2*3600,         # Central European Daylight
              "eest" =>   +3*3600,         # Eastern European Summer
              "msd"  =>   +4*3600,         # Moscow Daylight
  	    "wadt" =>   +8*3600,  	 # West Australian Daylight
  	    "kdt"  =>  +10*3600,	 # Korean Daylight
  	#   "cadt" =>  +10*3600+1800,	 # Central Australian Daylight
  	    "aedt" =>  +11*3600,  	 # Eastern Australian Daylight
  	    "eadt" =>  +11*3600,  	 # Eastern Australian Daylight
  	    "nzd"  =>  +13*3600,  	 # New Zealand Daylight   
  	    "nzdt" =>  +13*3600,  	 # New Zealand Daylight   
  	);
  
  	my @Zone = (
  	    "gmt"	=>   0,  	 # Greenwich Mean
  	    "ut"        =>   0,  	 # Universal (Coordinated)
  	    "utc"       =>   0,
  	    "wet"       =>   0,  	 # Western European
  	    "wat"       =>  -1*3600,	 # West Africa
  	    "at"        =>  -2*3600,	 # Azores
  	    "fnt"	=>  -2*3600,	 # Brazil Time (Extreme East - Fernando Noronha)
  	    "brt"	=>  -3*3600,	 # Brazil Time (East Standard - Brasilia)
  	# For completeness.  BST is also British Summer, and GST is also Guam Standard.
  	#   "bst"       =>  -3*3600,	 # Brazil Standard
  	#   "gst"       =>  -3*3600,	 # Greenland Standard
  	#   "nft"       =>  -3*3600-1800,# Newfoundland
  	#   "nst"       =>  -3*3600-1800,# Newfoundland Standard
  	    "mnt"	=>  -4*3600,	 # Brazil Time (West Standard - Manaus)
  	    "ewt"       =>  -4*3600,	 # U.S. Eastern War Time
  	    "ast"       =>  -4*3600,	 # Atlantic Standard
  	    "est"       =>  -5*3600,	 # Eastern Standard
  	    "act"	=>  -5*3600,	 # Brazil Time (Extreme West - Acre)
  	    "cst"       =>  -6*3600,	 # Central Standard
  	    "mst"       =>  -7*3600,	 # Mountain Standard
  	    "pst"       =>  -8*3600,	 # Pacific Standard
  	    "akst"      =>  -9*3600,     # Alaska Standard
  	    "yst"	=>  -9*3600,	 # Yukon Standard
  	    "hst"	=> -10*3600,	 # Hawaii Standard
  	    "cat"	=> -10*3600,	 # Central Alaska
  	    "ahst"	=> -10*3600,	 # Alaska-Hawaii Standard
  	    "nt"	=> -11*3600,	 # Nome
  	    "idlw"	=> -12*3600,	 # International Date Line West
  	    "cet"	=>  +1*3600, 	 # Central European
  	    "mez"	=>  +1*3600, 	 # Central European (German)
  	    "ect"	=>  +1*3600, 	 # Central European (French)
  	    "met"	=>  +1*3600, 	 # Middle European
  	    "mewt"	=>  +1*3600, 	 # Middle European Winter
  	    "swt"	=>  +1*3600, 	 # Swedish Winter
  	    "set"	=>  +1*3600, 	 # Seychelles
  	    "fwt"	=>  +1*3600, 	 # French Winter
  	    "eet"	=>  +2*3600, 	 # Eastern Europe, USSR Zone 1
  	    "ukr"	=>  +2*3600, 	 # Ukraine
  	    "bt"	=>  +3*3600, 	 # Baghdad, USSR Zone 2
              "msk"       =>  +3*3600,     # Moscow
  	#   "it"	=>  +3*3600+1800,# Iran
  	    "zp4"	=>  +4*3600, 	 # USSR Zone 3
  	    "zp5"	=>  +5*3600, 	 # USSR Zone 4
  	#   "ist"	=>  +5*3600+1800,# Indian Standard
  	    "zp6"	=>  +6*3600, 	 # USSR Zone 5
  	# For completeness.  NST is also Newfoundland Stanard, and SST is also Swedish Summer.
  	#   "nst"	=>  +6*3600+1800,# North Sumatra
  	#   "sst"	=>  +7*3600, 	 # South Sumatra, USSR Zone 6
  	#   "jt"	=>  +7*3600+1800,# Java (3pm in Cronusland!)
  	    "wst"	=>  +8*3600, 	 # West Australian Standard
  	    "hkt"	=>  +8*3600, 	 # Hong Kong
  	    "cct"	=>  +8*3600, 	 # China Coast, USSR Zone 7
  	    "jst"	=>  +9*3600,	 # Japan Standard, USSR Zone 8
  	    "kst"	=>  +9*3600,	 # Korean Standard
  	#   "cast"	=>  +9*3600+1800,# Central Australian Standard
  	    "aest"	=> +10*3600,	 # Eastern Australian Standard
  	    "east"	=> +10*3600,	 # Eastern Australian Standard
  	    "gst"	=> +10*3600,	 # Guam Standard, USSR Zone 9
  	    "nzt"	=> +12*3600,	 # New Zealand
  	    "nzst"	=> +12*3600,	 # New Zealand Standard
  	    "idle"	=> +12*3600,	 # International Date Line East
  	);
  
  	%Zone = @Zone;
  	%dstZone = @dstZone;
  	%zoneOff = reverse(@Zone);
  	%dstZoneOff = reverse(@dstZone);
  
  }
  
  sub tz_offset (;$$)
  {
  	my ($zone, $time) = @_;
  
  	return &tz_local_offset($time) unless($zone);
  
  	$time = time() unless $time;
  	my(@l) = localtime($time);
  	my $dst = $l[8];
  
  	$zone = lc $zone;
  
  	if($zone =~ /^(([\-\+])\d\d?)(\d\d)$/) {
  		my $v = $2 . $3;
  		return $1 * 3600 + $v * 60;
  	} elsif (exists $dstZone{$zone} && ($dst || !exists $Zone{$zone})) {
  		return $dstZone{$zone};
  	} elsif(exists $Zone{$zone}) {
  		return $Zone{$zone};
  	}
  	undef;
  }
  
  sub tz_name (;$$)
  {
  	my ($off, $dst) = @_;
  
  	$off = tz_offset()
  		unless(defined $off);
  
  	$dst = (localtime(time))[8]
  		unless(defined $dst);
  
  	if (exists $dstZoneOff{$off} && ($dst || !exists $zoneOff{$off})) {
  		return $dstZoneOff{$off};
  	} elsif (exists $zoneOff{$off}) {
  		return $zoneOff{$off};
  	}
  	sprintf("%+05d", int($off / 60) * 100 + $off % 60);
  }
  
  1;
TIME_ZONE

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/perl -w

eval 'exec /usr/bin/perl -w -S $0 ${1+"$@"}'
    if 0; # not running under some shell
# 2CN4sip - pt (PipTime) created by Pip@CPAN.Org (Mon Dec 23 04:54:44:51 2002)
# Desc: pt is a simple tool created to en/decode the date && time using 
#     typically seven (7) bass64 characters.  They are in decending order such
#     that alphabetic listings will (almost always) show time ascension &&
#     field arithmetic can be easily performed.
#   Each character is (usually) a single field in the order:
#     Year - 2000, Month, Day, hour, minute, second, frame (60th-of-a-Second)
#   Please see `perldoc Time::PT` for more info.
# Lice: Most source code should be Free!
#     Code I have lawful authority over is && shall be!
#   Copyright: (c) 2003, Pip Stuart.  All rights reserved.
#   Copyleft :  I license this software under the GNU General Public
#     License (version 2).  Please consult the Free Software Foundation
#     (http://www.fsf.org) for important information about your freedom.
use strict; 
use Time::PT; my $parm = join(' ', @ARGV); my $ptim = Time::PT->new();
if($parm =~ /(^|\s)-+h/i) {
  print "pt help: please run \`perldoc Time::PT\`\n";
} else {
  if     ($parm eq '-cp') {
    print $ptim->color('zsh'); exit;
  } elsif($parm =~ /-4(.*)$/) {
    print $ptim->color('4NT'); exit;
  } elsif($parm =~ /-c(.*)$/) {
    $ptim = Time::PT->new('verbose' => $1) if(defined($1));
    print $ptim->color('ansi'); exit;
  } elsif($parm =~ /^(e|pt)$/) {
    print $ptim->expand(); exit;
  } elsif($parm) {
    if(@ARGV >  1) { $ptim = Time::PT->new('verbose' => $parm); }
    if(@ARGV == 1) { $ptim = Time::PT->new('str'     => $parm)->expand(); }
  }
  print $ptim;
}
